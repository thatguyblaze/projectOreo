<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Virus Outbreak Simulator</title>
    <script src="https://cdn.tailwindcss.com?plugins=forms"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none; /* Prevent pull-to-refresh */
            margin: 0; /* Ensure no default body margin */
            height: 100vh; /* Ensure body takes full viewport height */
            display: flex; /* Use flexbox for layout */
        }
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        ::-webkit-scrollbar-track {
            background: #1f2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4b5563; /* gray-600 */
            border-radius: 3px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6b7280; /* gray-500 */
        }
        canvas {
            display: block; /* Remove scrollbars if canvas causes them */
            width: 100%; /* Make canvas fill container */
            height: 100%;
        }
        #canvas-container {
             flex: 1; /* Allow container to grow */
             position: relative; /* Needed for absolute positioning of tooltip */
             min-width: 0; /* Prevent flexbox overflow issues */
             min-height: 0;
             background-color: #111827; /* Match scene background */
        }
        .tooltip {
            position: absolute;
            background-color: rgba(31, 41, 55, 0.9); /* gray-800 with opacity */
            color: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            pointer-events: none; /* Allow clicks to pass through */
            white-space: pre-line; /* Respect newlines */
            z-index: 100;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
            border: 1px solid #4b5563; /* gray-600 */
        }
        .slider-label {
            @apply text-sm font-medium text-gray-300 mb-1 flex justify-between;
        }
        .slider {
            @apply w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500;
        }
        .control-button {
             /* Base styles */
            @apply px-3 py-1.5 text-sm font-semibold rounded-md shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 transition-colors duration-150 ease-in-out;
            /* Color styles */
            @apply bg-gray-700 text-white hover:bg-gray-600 focus-visible:outline-gray-500;
            /* Disabled styles */
            @apply disabled:opacity-50 disabled:cursor-not-allowed;
        }
        .start-button {
             /* Base styles */
            @apply px-4 py-2 text-base font-semibold rounded-md shadow-sm focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 transition-colors duration-150 ease-in-out w-full;
            /* Color styles */
            @apply bg-green-600 text-white hover:bg-green-500 focus-visible:outline-green-600;
            /* Disabled styles */
            @apply disabled:opacity-50 disabled:cursor-not-allowed;
        }
         /* Style for the message box */
        #message-box {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(31, 41, 55, 0.95); /* gray-800 */
            color: white;
            padding: 12px 20px;
            border-radius: 6px;
            border: 1px solid #4b5563; /* gray-600 */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease-in-out, top 0.3s ease-in-out;
            pointer-events: none;
            font-size: 0.9rem;
            max-width: 80%;
            text-align: center;
        }
        #message-box.show {
            opacity: 1;
            top: 30px;
        }

    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex h-screen overflow-hidden">

    <div class="w-64 lg:w-72 bg-gray-800 p-4 flex flex-col border-r border-gray-700 shadow-lg overflow-y-auto flex-shrink-0">
        <h1 class="text-xl font-bold mb-4 text-white">Virus Control</h1>

        <div id="status-message" class="text-sm text-yellow-400 mb-3 p-2 bg-gray-700 rounded">
            Select a starting country on the map.
        </div>

        <div class="mb-4 p-3 bg-gray-700 rounded">
            <h2 class="text-lg font-semibold mb-2 text-gray-200">Global Status</h2>
            <div class="text-sm space-y-1">
                <p>Days Passed: <span id="days-passed" class="font-medium text-white">0</span></p>
                <p>Infected: <span id="total-infected" class="font-medium text-red-400">0</span></p>
                <p>Dead: <span id="total-dead" class="font-medium text-gray-400">0</span></p>
                <p>Healthy: <span id="total-healthy" class="font-medium text-green-400">0</span></p>
                <p>World Population: <span id="world-population" class="font-medium text-white">0</span></p>
            </div>
        </div>

        <div class="mb-4 p-3 bg-gray-700 rounded">
            <h2 class="text-lg font-semibold mb-3 text-gray-200">Virus Parameters</h2>
            <div class="space-y-3">
                <div>
                    <label for="infection-rate" class="slider-label"><span>Infectivity</span><span id="infection-rate-value">5</span></label>
                    <input type="range" id="infection-rate" min="1" max="10" value="5" class="slider">
                </div>
                <div>
                    <label for="lethality" class="slider-label"><span>Lethality</span><span id="lethality-value">1</span></label>
                    <input type="range" id="lethality" min="0" max="10" value="1" class="slider">
                </div>
                <div>
                    <label for="transmission" class="slider-label"><span>Transmission</span><span id="transmission-value">3</span></label>
                    <input type="range" id="transmission" min="1" max="10" value="3" class="slider">
                </div>
            </div>
        </div>

        <div class="p-3 bg-gray-700 rounded">
            <h2 class="text-lg font-semibold mb-3 text-gray-200">Time Controls</h2>
            <div class="flex space-x-2">
                <button id="pause-button" class="control-button flex-1">Pause</button>
                <button id="speed-button" class="control-button flex-1">Speed x1</button>
            </div>
        </div>

        <div class="mt-auto pt-4">
             <button id="start-button" class="start-button" disabled>Start Simulation</button>
         </div>
    </div>

    <div id="canvas-container" class="flex-1 relative">
        </div>

    <div id="tooltip" class="tooltip">Tooltip content</div>

    <div id="message-box"></div>

    <script type="module">
        // --- Three.js Setup ---
        let scene, camera, renderer; // Removed 'controls' as it wasn't used
        let raycaster, mouse;
        const countryNodes = []; // Stores { mesh, data }
        const connectionLines = []; // Stores lines visualizing connections
        const spreadLines = []; // Stores lines visualizing active spread
        let canvasContainer, tooltip, messageBox; // Declare here, assign in DOMContentLoaded
        let hoveredNode = null;

        // --- Game State ---
        let gameRunning = false;
        let gamePaused = false;
        let daysPassed = 0;
        let timeSpeed = 1; // 1 = normal, 2 = 2x, 4 = 4x
        let gameLoopInterval;
        let selectedStartCountry = null;
        let totalPopulation = 0;

        // --- Game Parameters ---
        let infectionRate = 5; // Base infectivity (1-10)
        let lethality = 1;     // Base lethality (0-10)
        let transmission = 3;  // Base transmission (1-10)

        // --- UI Elements ---
        // Declare here, assign in DOMContentLoaded
        let infectionRateSlider, lethalitySlider, transmissionSlider;
        let infectionRateValue, lethalityValue, transmissionValue;
        let daysPassedDisplay, totalInfectedDisplay, totalDeadDisplay, totalHealthyDisplay, worldPopulationDisplay;
        let pauseButton, speedButton, startButton, statusMessage;

        // --- Colors ---
        const COLOR_HEALTHY = new THREE.Color(0x22c55e); // green-500
        const COLOR_INFECTED_LOW = new THREE.Color(0xfacc15); // yellow-400
        const COLOR_INFECTED_HIGH = new THREE.Color(0xef4444); // red-500
        const COLOR_DEAD = new THREE.Color(0x6b7280); // gray-500
        const COLOR_SELECTED = new THREE.Color(0x3b82f6); // blue-500
        const COLOR_CONNECTION = new THREE.Color(0x4b5563); // gray-600
        const COLOR_SPREAD = new THREE.Color(0xf87171); // red-400

        // --- Simplified Country Data ---
        const countryData = [
            // ... (Country data remains the same as previous version) ...
            { name: "USA", population: 3300, x: -100, y: 50, z: 0, connections: ["Canada", "Mexico", "UK", "Japan"] },
            { name: "Canada", population: 380, x: -90, y: 80, z: 0, connections: ["USA", "Greenland", "UK"] },
            { name: "Mexico", population: 1300, x: -100, y: 20, z: 0, connections: ["USA", "Brazil"] },
            { name: "Brazil", population: 2100, x: -50, y: -30, z: 0, connections: ["Mexico", "Argentina", "Nigeria", "Spain"] },
            { name: "Argentina", population: 450, x: -60, y: -60, z: 0, connections: ["Brazil", "South Africa"] },
            { name: "Greenland", population: 1, x: -40, y: 100, z: 0, connections: ["Canada", "Iceland"] },
            { name: "Iceland", population: 4, x: -20, y: 90, z: 0, connections: ["Greenland", "UK", "Norway"] },
            { name: "UK", population: 670, x: 0, y: 60, z: 0, connections: ["USA", "Canada", "Iceland", "France", "Norway"] },
            { name: "France", population: 650, x: 10, y: 50, z: 0, connections: ["UK", "Spain", "Germany", "Italy", "Algeria"] },
            { name: "Spain", population: 470, x: -5, y: 40, z: 0, connections: ["France", "Portugal", "Morocco", "Brazil"] },
            { name: "Portugal", population: 100, x: -15, y: 40, z: 0, connections: ["Spain"] },
            { name: "Germany", population: 830, x: 20, y: 55, z: 0, connections: ["France", "Poland", "Italy"] },
            { name: "Italy", population: 600, x: 25, y: 45, z: 0, connections: ["France", "Germany", "Greece", "Libya"] },
            { name: "Poland", population: 380, x: 35, y: 55, z: 0, connections: ["Germany", "Russia", "Ukraine"] },
            { name: "Norway", population: 50, x: 20, y: 75, z: 0, connections: ["UK", "Iceland", "Sweden", "Russia"] },
            { name: "Sweden", population: 100, x: 30, y: 70, z: 0, connections: ["Norway", "Finland", "Germany"] },
            { name: "Finland", population: 55, x: 40, y: 75, z: 0, connections: ["Sweden", "Norway", "Russia"] },
            { name: "Russia", population: 1450, x: 80, y: 60, z: 0, connections: ["Finland", "Norway", "Poland", "Ukraine", "China", "Mongolia", "Kazakhstan"] },
            { name: "Ukraine", population: 440, x: 50, y: 50, z: 0, connections: ["Poland", "Russia", "Turkey"] },
            { name: "Turkey", population: 840, x: 55, y: 40, z: 0, connections: ["Ukraine", "Greece", "Egypt", "Iran"] },
            { name: "Greece", population: 100, x: 40, y: 40, z: 0, connections: ["Italy", "Turkey", "Egypt"] },
            { name: "Egypt", population: 1020, x: 45, y: 25, z: 0, connections: ["Greece", "Turkey", "Libya", "Sudan", "Saudi Arabia"] },
            { name: "Libya", population: 70, x: 30, y: 25, z: 0, connections: ["Italy", "Egypt", "Algeria", "Nigeria"] },
            { name: "Algeria", population: 440, x: 5, y: 28, z: 0, connections: ["France", "Libya", "Morocco", "Nigeria"] },
            { name: "Morocco", population: 370, x: -10, y: 30, z: 0, connections: ["Spain", "Algeria"] },
            { name: "Nigeria", population: 2100, x: 15, y: 10, z: 0, connections: ["Brazil", "Algeria", "Libya", "Sudan", "Congo"] },
            { name: "Sudan", population: 440, x: 45, y: 15, z: 0, connections: ["Egypt", "Nigeria", "Ethiopia", "Congo"] },
            { name: "Ethiopia", population: 1150, x: 55, y: 10, z: 0, connections: ["Sudan", "Kenya", "Saudi Arabia"] },
            { name: "Kenya", population: 540, x: 55, y: 0, z: 0, connections: ["Ethiopia", "Tanzania", "Congo"] },
            { name: "Tanzania", population: 600, x: 50, y: -5, z: 0, connections: ["Kenya", "Congo", "Madagascar", "South Africa"] },
            { name: "Congo", population: 900, x: 35, y: 0, z: 0, connections: ["Nigeria", "Sudan", "Kenya", "Tanzania", "South Africa"] },
            { name: "South Africa", population: 600, x: 40, y: -30, z: 0, connections: ["Argentina", "Tanzania", "Congo", "Madagascar", "Australia"] },
            { name: "Madagascar", population: 280, x: 65, y: -20, z: 0, connections: ["Tanzania", "South Africa", "Australia"] },
            { name: "Saudi Arabia", population: 350, x: 65, y: 25, z: 0, connections: ["Egypt", "Ethiopia", "Iran", "India"] },
            { name: "Iran", population: 840, x: 75, y: 35, z: 0, connections: ["Turkey", "Russia", "Saudi Arabia", "Pakistan", "Kazakhstan"] },
            { name: "Pakistan", population: 2250, x: 85, y: 30, z: 0, connections: ["Iran", "India", "China", "Afghanistan"] },
            { name: "Afghanistan", population: 390, x: 85, y: 35, z: 0, connections: ["Iran", "Pakistan", "China", "Kazakhstan"] },
            { name: "Kazakhstan", population: 190, x: 90, y: 50, z: 0, connections: ["Russia", "Iran", "Afghanistan", "China", "Mongolia"] },
            { name: "Mongolia", population: 30, x: 110, y: 50, z: 0, connections: ["Russia", "China", "Kazakhstan"] },
            { name: "China", population: 14000, x: 115, y: 35, z: 0, connections: ["Russia", "Pakistan", "Afghanistan", "Kazakhstan", "Mongolia", "India", "Vietnam", "Japan", "Philippines"] },
            { name: "India", population: 13800, x: 95, y: 20, z: 0, connections: ["Saudi Arabia", "Pakistan", "China", "Thailand", "Indonesia"] },
            { name: "Thailand", population: 700, x: 115, y: 15, z: 0, connections: ["India", "China", "Vietnam", "Indonesia", "Australia"] },
            { name: "Vietnam", population: 970, x: 120, y: 18, z: 0, connections: ["China", "Thailand", "Philippines"] },
            { name: "Indonesia", population: 2700, x: 120, y: -5, z: 0, connections: ["India", "Thailand", "Australia", "Philippines"] },
            { name: "Philippines", population: 1100, x: 135, y: 15, z: 0, connections: ["China", "Vietnam", "Indonesia", "Japan", "Australia"] },
            { name: "Japan", population: 1260, x: 145, y: 35, z: 0, connections: ["USA", "China", "Russia", "Philippines"] },
            { name: "Australia", population: 260, x: 140, y: -25, z: 0, connections: ["South Africa", "Madagascar", "Thailand", "Indonesia", "Philippines", "New Zealand"] },
            { name: "New Zealand", population: 50, x: 170, y: -40, z: 0, connections: ["Australia"] },
        ];

        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827); // gray-900

            // Camera Setup (Ensure aspect ratio is correct)
            const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            const frustumSize = 250; // Adjust this to control zoom level
            camera = new THREE.OrthographicCamera(frustumSize * aspect / -2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / -2, 1, 1000);
            camera.position.set(0, 0, 50); // Look straight down
            camera.lookAt(scene.position);

            // Renderer
            try {
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
                canvasContainer.appendChild(renderer.domElement); // Append renderer here
            } catch (e) {
                console.error("Error creating WebGL Renderer:", e);
                showMessage("Error: Could not initialize graphics. Your browser might not support WebGL.", 10000);
                return; // Stop initialization if renderer fails
            }


            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            raycaster.params.Points.threshold = 5; // Adjust threshold as needed
            mouse = new THREE.Vector2();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.0);
            scene.add(ambientLight);

            // Create Country Nodes and Calculate Total Population
            createCountryNodes();
            worldPopulationDisplay.textContent = totalPopulation.toLocaleString();
            updateGlobalCounts(); // Initialize healthy count

            // Draw Connection Lines
            drawConnectionLines();

            // Attach Event Listeners
            addEventListeners();

            // Initial parameter display
            updateParameters();

            // Start Animation Loop
            animate();
        }

        // --- Assign DOM Elements ---
        function assignDOMElements() {
            canvasContainer = document.getElementById('canvas-container');
            tooltip = document.getElementById('tooltip');
            messageBox = document.getElementById('message-box');

            infectionRateSlider = document.getElementById('infection-rate');
            lethalitySlider = document.getElementById('lethality');
            transmissionSlider = document.getElementById('transmission');
            infectionRateValue = document.getElementById('infection-rate-value');
            lethalityValue = document.getElementById('lethality-value');
            transmissionValue = document.getElementById('transmission-value');
            daysPassedDisplay = document.getElementById('days-passed');
            totalInfectedDisplay = document.getElementById('total-infected');
            totalDeadDisplay = document.getElementById('total-dead');
            totalHealthyDisplay = document.getElementById('total-healthy');
            worldPopulationDisplay = document.getElementById('world-population');
            pauseButton = document.getElementById('pause-button');
            speedButton = document.getElementById('speed-button');
            startButton = document.getElementById('start-button');
            statusMessage = document.getElementById('status-message');

            // Basic check if elements exist
            if (!canvasContainer || !startButton) {
                console.error("Essential DOM elements not found!");
                return false;
            }
            return true;
        }

        // --- Add Event Listeners ---
        function addEventListeners() {
            window.addEventListener('resize', onWindowResize);
            // Ensure canvasContainer is valid before adding listeners
            if (canvasContainer) {
                 canvasContainer.addEventListener('mousemove', onMouseMove);
                 canvasContainer.addEventListener('click', onMouseClick);
                 canvasContainer.addEventListener('mouseout', clearHover); // Clear hover when mouse leaves canvas
            }
            infectionRateSlider.addEventListener('input', updateParameters);
            lethalitySlider.addEventListener('input', updateParameters);
            transmissionSlider.addEventListener('input', updateParameters);
            pauseButton.addEventListener('click', togglePause);
            speedButton.addEventListener('click', cycleSpeed);
            startButton.addEventListener('click', startGame);
        }


        // --- Create Country Nodes ---
        function createCountryNodes() {
            const geometry = new THREE.SphereGeometry(3, 16, 16); // Simple sphere for nodes

            countryData.forEach(data => {
                const material = new THREE.MeshBasicMaterial({ color: COLOR_HEALTHY, wireframe: false }); // Ensure wireframe is off
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.set(data.x, data.y, data.z);

                // Store game data within the mesh's userData
                mesh.userData = {
                    ...data, // Copy original data
                    id: data.name,
                    infected: 0,
                    dead: 0,
                    healthy: data.population, // Initial state
                    isStartingPoint: false,
                    neighbors: [], // Will be populated later by name lookup
                    status: 'healthy' // 'healthy', 'infected', 'dead'
                };

                totalPopulation += data.population;
                scene.add(mesh);
                countryNodes.push({ mesh, data: mesh.userData });
            });

             // After creating all nodes, map connection names to actual node references
             const nodeMap = new Map(countryNodes.map(n => [n.data.name, n]));

             countryNodes.forEach(nodeWrapper => {
                 const nodeData = nodeWrapper.data;
                 // Check if connections array exists and is an array
                 if (Array.isArray(nodeData.connections)) {
                     nodeData.neighbors = nodeData.connections
                         .map(neighborName => nodeMap.get(neighborName)) // Get the neighbor node wrapper
                         .filter(neighborNode => neighborNode !== undefined); // Filter out undefined if connection name is wrong
                 } else {
                      console.warn(`Node ${nodeData.name} has invalid connections data:`, nodeData.connections);
                      nodeData.neighbors = []; // Ensure neighbors is always an array
                 }
             });
        }

        // --- Draw Connection Lines ---
        function drawConnectionLines() {
            // Check if scene exists
            if (!scene) {
                console.error("Scene not initialized for drawing connection lines.");
                return;
            }
            const material = new THREE.LineBasicMaterial({
                color: COLOR_CONNECTION,
                linewidth: 0.5, // Note: linewidth > 1 might not work on all platforms
                transparent: true,
                opacity: 0.3
             });
            const nodeMap = new Map(countryNodes.map(n => [n.data.name, n]));

            countryData.forEach(data => {
                const startNode = nodeMap.get(data.name);
                if (!startNode) {
                    // console.warn(`Start node not found for connection: ${data.name}`);
                    return;
                }

                // Ensure connections is an array before iterating
                if (!Array.isArray(data.connections)) return;

                data.connections.forEach(neighborName => {
                    const endNode = nodeMap.get(neighborName);
                    if (!endNode) {
                        // console.warn(`End node not found for connection: ${neighborName} from ${data.name}`);
                        return;
                    }

                    // Avoid drawing duplicate lines & self-connections
                    if (startNode.data.name < endNode.data.name) {
                        try {
                            const points = [startNode.mesh.position.clone(), endNode.mesh.position.clone()];
                            const geometry = new THREE.BufferGeometry().setFromPoints(points);
                            const line = new THREE.Line(geometry, material);
                            scene.add(line); // Add line to the scene
                            connectionLines.push(line);
                        } catch (error) {
                            console.error("Error creating or adding line:", error, "Data:", data, "Neighbor:", neighborName);
                        }
                    }
                });
            });
        }


        // --- Game Logic ---
        function gameTick() {
            if (!gameRunning || gamePaused) return;

            daysPassed++;
            daysPassedDisplay.textContent = daysPassed;

            const newlyInfectedToday = new Map(); // Map<countryNodeWrapper, count>
            const newlyDeadToday = new Map();     // Map<countryNodeWrapper, count>
            const spreadEvents = []; // Store { from: nodeWrapper, to: nodeWrapper }

            // --- 1. Spread Infection ---
            countryNodes.forEach(nodeWrapper => {
                const nodeData = nodeWrapper.data;
                if (nodeData.status === 'infected' && nodeData.infected > 0) {

                    // --- Spread to neighbors ---
                    if (Array.isArray(nodeData.neighbors)) { // Check neighbors is an array
                        nodeData.neighbors.forEach(neighborWrapper => {
                            const neighborData = neighborWrapper.data;
                            if (neighborData.status !== 'dead' && neighborData.population > 0) {
                                // Calculate spread chance
                                const infectionPressure = (nodeData.infected / nodeData.population) * (infectionRate / 5) * (transmission / 5);
                                const targetResistance = Math.max(0, 1 - (neighborData.infected / neighborData.population)); // Prevent negative resistance
                                const spreadChance = Math.min(0.1, infectionPressure * targetResistance) * 0.1; // Scaled down daily chance per connection

                                if (Math.random() < spreadChance) {
                                    // How many get infected? Simulate based on number already infected in source
                                    // More realistic: Base on healthy population in target and pressure from source
                                    const potentialNewInfections = Math.ceil(neighborData.healthy * (infectionRate / 100) * (transmission / 10) * (nodeData.infected / nodeData.population));
                                    const actualNewInfections = Math.min(neighborData.healthy, Math.max(1, potentialNewInfections)); // Infect at least 1 if chance hits

                                    if (actualNewInfections > 0) {
                                        newlyInfectedToday.set(neighborWrapper, (newlyInfectedToday.get(neighborWrapper) || 0) + actualNewInfections);
                                        spreadEvents.push({ from: nodeWrapper, to: neighborWrapper });
                                    }
                                }
                            }
                        });
                    } else {
                         // console.warn(`Neighbors data missing or invalid for ${nodeData.name}`);
                    }


                    // --- Internal spread ---
                    if (nodeData.healthy > 0) {
                        const internalSpreadChance = (infectionRate / 10) * 0.05 * (nodeData.infected / nodeData.population); // Scaled daily chance, higher if more infected
                        const potentialInternalInfections = Math.ceil(nodeData.healthy * internalSpreadChance);
                        const actualInternalInfections = Math.min(nodeData.healthy, Math.max(1, potentialInternalInfections)); // Infect at least 1 if chance hits and healthy > 0
                        if (actualInternalInfections > 0 && Math.random() < 0.5) { // Add some randomness to internal spread too
                            newlyInfectedToday.set(nodeWrapper, (newlyInfectedToday.get(nodeWrapper) || 0) + actualInternalInfections);
                        }
                    }
                }
            });

            // --- 2. Apply Lethality ---
            countryNodes.forEach(nodeWrapper => {
                 const nodeData = nodeWrapper.data;
                if (nodeData.status === 'infected' && nodeData.infected > 0) {
                    const deathChance = (lethality / 10) * 0.01; // Scaled daily chance per infected person
                    let actualDeaths = 0;
                    for(let i = 0; i < Math.floor(nodeData.infected); i++) { // Simulate per person for lower pops
                        if (Math.random() < deathChance) {
                            actualDeaths++;
                        }
                    }
                    // Ensure we don't kill more than are infected
                    actualDeaths = Math.min(nodeData.infected, actualDeaths);

                    if (actualDeaths > 0) {
                         newlyDeadToday.set(nodeWrapper, (newlyDeadToday.get(nodeWrapper) || 0) + actualDeaths);
                    }
                }
            });


            // --- 3. Update Country States ---
            // Apply deaths first
            newlyDeadToday.forEach((count, nodeWrapper) => {
                const nodeData = nodeWrapper.data;
                const deathsToAdd = Math.min(nodeData.infected, count); // Ensure we don't kill more than infected
                nodeData.dead += deathsToAdd;
                nodeData.infected -= deathsToAdd;
            });

            // Apply new infections
            newlyInfectedToday.forEach((count, nodeWrapper) => {
                 const nodeData = nodeWrapper.data;
                const infectionsToAdd = Math.min(nodeData.healthy, count); // Ensure we don't infect more than available healthy
                nodeData.infected += infectionsToAdd;
                nodeData.healthy -= infectionsToAdd;
                if (infectionsToAdd > 0) {
                    nodeData.status = 'infected'; // Only change status if new infections occurred
                }
            });

            // Update status for nodes that might have changed
             countryNodes.forEach(nodeWrapper => {
                 const nodeData = nodeWrapper.data;
                 // If population reaches 0 or only dead remain, mark as 'dead'
                 if (nodeData.healthy <= 0 && nodeData.infected <= 0 && nodeData.population > 0) {
                     nodeData.status = 'dead';
                     nodeData.infected = 0; // Ensure infected count is 0 if dead
                     nodeData.healthy = 0; // Ensure healthy count is 0 if dead
                     nodeData.dead = nodeData.population; // Cap dead at total population
                 } else if (nodeData.infected <= 0 && nodeData.status === 'infected') {
                     // If no more infected, revert to healthy (unless all dead)
                     nodeData.status = 'healthy';
                 }
                 // Clamp values
                 nodeData.infected = Math.max(0, nodeData.infected);
                 nodeData.healthy = Math.max(0, nodeData.healthy);
                 nodeData.dead = Math.min(nodeData.population, Math.max(0, nodeData.dead));
                 // Recalculate healthy just in case of float issues
                 nodeData.healthy = nodeData.population - nodeData.infected - nodeData.dead;

             });


            // --- 4. Update Visuals ---
            updateNodeColors();
            updateGlobalCounts();
            visualizeSpread(spreadEvents);

            // --- 5. Check Win/Loss Condition ---
             const currentTotals = calculateGlobalTotals();
             if (gameRunning) { // Only check end conditions if game is supposed to be running
                 if (currentTotals.infected <= 0 && daysPassed > 1) { // Check if infection died out
                     if (currentTotals.healthy === totalPopulation) {
                          endGame("Virus Eradicated! Humanity is safe.");
                     } else if (currentTotals.healthy <= 0) {
                          endGame("Extinction! The virus has wiped out humanity.");
                     } else {
                          endGame(`Containment Achieved! The virus died out after ${currentTotals.dead.toLocaleString()} deaths.`);
                     }
                 }
             }
        }

         // --- Visualize Spread ---
        function visualizeSpread(spreadEvents) {
            // Clear previous spread lines
            spreadLines.forEach(line => scene.remove(line));
            spreadLines.length = 0; // Clear the array

            if (spreadEvents.length === 0) return; // Don't proceed if no events

            const material = new THREE.LineBasicMaterial({
                color: COLOR_SPREAD,
                linewidth: 1.5, // Make spread lines slightly thicker
                transparent: true,
                opacity: 0.8, // Make them more visible
                depthTest: false // Render on top
            });

            spreadEvents.forEach(event => {
                // Check if nodes and positions exist
                if (event.from?.mesh?.position && event.to?.mesh?.position) {
                    const points = [event.from.mesh.position.clone(), event.to.mesh.position.clone()];
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, material.clone()); // Clone material if modifying opacity later
                    scene.add(line);
                    spreadLines.push(line);

                    // Optional: Fade out lines after a short duration
                    // setTimeout(() => {
                    //     if (scene.children.includes(line)) { // Check if still in scene
                    //         scene.remove(line);
                    //         const index = spreadLines.indexOf(line);
                    //         if (index > -1) spreadLines.splice(index, 1);
                    //     }
                    // }, 500); // Fade after 0.5 seconds
                } else {
                    console.warn("Skipping spread visualization due to missing node data:", event);
                }
            });
        }


        // --- Update Node Colors Based on Status ---
        function updateNodeColors() {
            countryNodes.forEach(nodeWrapper => {
                const nodeData = nodeWrapper.data;
                const mesh = nodeWrapper.mesh;
                let targetColor = COLOR_HEALTHY; // Default

                if (nodeData.isStartingPoint && !gameRunning) {
                    targetColor = COLOR_SELECTED;
                } else if (nodeData.status === 'dead') {
                    targetColor = COLOR_DEAD;
                } else if (nodeData.status === 'infected') {
                    // Interpolate color based on infection percentage
                    // Make red more prominent earlier
                    const infectionRatio = nodeData.population > 0 ? Math.min(1, nodeData.infected / (nodeData.population * 0.5)) : 0;
                    targetColor = COLOR_HEALTHY.clone().lerp(COLOR_INFECTED_HIGH, infectionRatio); // Lerp from Green to Red
                }
                // Smoothly transition color if material exists
                if (mesh.material) {
                    mesh.material.color.lerp(targetColor, 0.1);
                }
            });
        }

        // --- Calculate and Update Global Counts ---
        function calculateGlobalTotals() {
            let infected = 0;
            let dead = 0;
            let healthy = 0;
            countryNodes.forEach(nodeWrapper => {
                infected += nodeWrapper.data.infected;
                dead += nodeWrapper.data.dead;
                healthy += nodeWrapper.data.healthy;
            });

            // Floor values for display and comparison
            infected = Math.floor(infected);
            dead = Math.floor(dead);
            // Recalculate healthy based on floored infected/dead to ensure consistency
            healthy = totalPopulation - infected - dead;

            return { infected, dead, healthy };
        }

        function updateGlobalCounts() {
            const totals = calculateGlobalTotals();
            totalInfectedDisplay.textContent = totals.infected.toLocaleString();
            totalDeadDisplay.textContent = totals.dead.toLocaleString();
            totalHealthyDisplay.textContent = totals.healthy.toLocaleString();
        }


        // --- Event Handlers ---
        function onWindowResize() {
            if (!camera || !renderer || !canvasContainer) return; // Check if initialized

            const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight;
            const frustumSize = 250; // Keep consistent zoom level

            camera.left = frustumSize * aspect / -2;
            camera.right = frustumSize * aspect / 2;
            camera.top = frustumSize / 2;
            camera.bottom = frustumSize / -2;
            camera.updateProjectionMatrix();

            renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        }

        function onMouseMove(event) {
            if (!canvasContainer || !raycaster || !camera) return;
            event.preventDefault();

            // Calculate mouse position in normalized device coordinates (-1 to +1)
            const rect = canvasContainer.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; // Use rect.width
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; // Use rect.height

            // Update the picking ray
            raycaster.setFromCamera(mouse, camera);

            // Check intersections
            const intersects = raycaster.intersectObjects(countryNodes.map(n => n.mesh));

            if (intersects.length > 0) {
                // Find the corresponding node wrapper for the intersected mesh
                const intersectedNodeWrapper = countryNodes.find(n => n.mesh === intersects[0].object);
                if (intersectedNodeWrapper) {
                    if (hoveredNode !== intersectedNodeWrapper) {
                        // Clear previous hover effect if any (like scaling)
                        clearHoverEffect();

                        hoveredNode = intersectedNodeWrapper;
                        applyHoverEffect(hoveredNode); // Apply new effect

                        updateTooltip(hoveredNode.data, event.clientX, event.clientY);
                        tooltip.style.opacity = '1';
                    } else {
                        // Update tooltip position even if it's the same node
                        updateTooltipPosition(event.clientX, event.clientY);
                    }
                    canvasContainer.style.cursor = 'pointer';
                } else {
                    clearHover(); // Intersected object not found in our nodes list
                }
            } else {
                clearHover(); // No intersection
            }
        }

        function applyHoverEffect(nodeWrapper) {
             // Example: Slightly scale up the hovered node
             // nodeWrapper.mesh.scale.set(1.2, 1.2, 1.2);
             // Or change material property slightly
             // nodeWrapper.mesh.material.opacity = 0.8; // Requires transparent=true
        }

        function clearHoverEffect() {
             if (hoveredNode) {
                 // Reset any visual changes made by applyHoverEffect
                 // hoveredNode.mesh.scale.set(1, 1, 1);
                 // hoveredNode.mesh.material.opacity = 1.0;
             }
        }


         function clearHover() {
             clearHoverEffect(); // Reset visual effect
             hoveredNode = null;
             if (tooltip) tooltip.style.opacity = '0';
             if (canvasContainer) canvasContainer.style.cursor = 'default';
         }


        function onMouseClick(event) {
            if (gameRunning || !canvasContainer || !raycaster || !camera) return; // Don't allow selection after game starts or if not ready

            // Calculate mouse position
             const rect = canvasContainer.getBoundingClientRect();
             mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
             mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

             raycaster.setFromCamera(mouse, camera);
             const intersects = raycaster.intersectObjects(countryNodes.map(n => n.mesh));

             if (intersects.length > 0) {
                 const clickedNodeWrapper = countryNodes.find(n => n.mesh === intersects[0].object);
                 if (clickedNodeWrapper) {
                     selectStartCountry(clickedNodeWrapper);
                 }
             }
        }

        function updateParameters() {
            // Ensure sliders exist before reading values
            if (!infectionRateSlider || !lethalitySlider || !transmissionSlider) return;

            infectionRate = parseInt(infectionRateSlider.value);
            lethality = parseInt(lethalitySlider.value);
            transmission = parseInt(transmissionSlider.value);

            // Ensure value displays exist
            if (infectionRateValue) infectionRateValue.textContent = infectionRate;
            if (lethalityValue) lethalityValue.textContent = lethality;
            if (transmissionValue) transmissionValue.textContent = transmission;
        }

        function selectStartCountry(nodeWrapper) {
            if (gameRunning || !nodeWrapper) return;

            // Deselect previous start country if any
            if (selectedStartCountry) {
                selectedStartCountry.data.isStartingPoint = false;
            }

            // Select the new one
            selectedStartCountry = nodeWrapper;
            selectedStartCountry.data.isStartingPoint = true;

            statusMessage.textContent = `Starting in: ${nodeWrapper.data.name}. Press Start.`;
            statusMessage.classList.remove('text-yellow-400');
            statusMessage.classList.add('text-green-400');
            startButton.disabled = false;

            // Update colors immediately to show selection
            updateNodeColors();
        }

        function startGame() {
            if (!selectedStartCountry) {
                showMessage("Please select a starting country first!");
                return;
            }
            if (gameRunning) return; // Prevent multiple starts

            gameRunning = true;
            gamePaused = false;
            daysPassed = 0;
            daysPassedDisplay.textContent = daysPassed; // Reset display


            // Infect the starting country (small initial amount)
            const startNodeData = selectedStartCountry.data;
            const initialInfection = Math.max(1, Math.min(startNodeData.healthy, 10)); // Infect ~10 people or max healthy if less
            startNodeData.infected += initialInfection;
            startNodeData.healthy -= initialInfection;
            startNodeData.status = 'infected';
            startNodeData.isStartingPoint = false; // Reset visual selection marker

            // Disable controls
            startButton.disabled = true;
            startButton.textContent = "Simulation Running";
            infectionRateSlider.disabled = true;
            lethalitySlider.disabled = true;
            transmissionSlider.disabled = true;
            pauseButton.disabled = false; // Enable pause/speed now
            speedButton.disabled = false;
            pauseButton.textContent = "Pause"; // Reset button text
            speedButton.textContent = `Speed x${timeSpeed}`; // Reset button text


            statusMessage.textContent = "Outbreak in progress...";
            statusMessage.classList.remove('text-green-400', 'text-yellow-400');
            statusMessage.classList.add('text-red-400');

            // Clear any existing interval and start the new one
            setGameLoopInterval();
            updateNodeColors(); // Update color for starting country
            updateGlobalCounts(); // Update counts after initial infection
        }

        function endGame(message) {
             gameRunning = false;
             gamePaused = true; // Effectively stop the loop
             clearInterval(gameLoopInterval);
             showMessage(message, 10000); // Show message for longer

             // Keep parameter sliders enabled, but disable time/start buttons
             startButton.disabled = true;
             startButton.textContent = "Simulation Ended";
             pauseButton.textContent = "Paused";
             pauseButton.disabled = true;
             speedButton.disabled = true;
             infectionRateSlider.disabled = false; // Allow changing params for next potential run (if restart added)
             lethalitySlider.disabled = false;
             transmissionSlider.disabled = false;


             statusMessage.textContent = "Simulation Ended.";
             statusMessage.classList.remove('text-red-400', 'text-green-400', 'text-yellow-400');
             statusMessage.classList.add('text-blue-400');

             // Clear active spread lines
             visualizeSpread([]);
        }


        function togglePause() {
            if (!gameRunning) return; // Only allow pause if game is running
            gamePaused = !gamePaused;
            pauseButton.textContent = gamePaused ? "Resume" : "Pause";
            if (gamePaused) {
                clearInterval(gameLoopInterval); // Stop interval when paused
                 statusMessage.textContent = "Simulation Paused.";
                 statusMessage.classList.remove('text-red-400');
                 statusMessage.classList.add('text-yellow-400');

            } else {
                setGameLoopInterval(); // Restart interval with current speed
                 statusMessage.textContent = "Outbreak in progress...";
                 statusMessage.classList.remove('text-yellow-400');
                 statusMessage.classList.add('text-red-400');
            }
        }

        function cycleSpeed() {
            if (!gameRunning) return;
            switch (timeSpeed) {
                case 1: timeSpeed = 2; break;
                case 2: timeSpeed = 4; break;
                case 4: timeSpeed = 1; break;
                default: timeSpeed = 1; // Reset if invalid state
            }
            speedButton.textContent = `Speed x${timeSpeed}`;
            // If game is running and not paused, update the interval
            if (gameRunning && !gamePaused) {
                setGameLoopInterval();
            }
        }

        function setGameLoopInterval() {
            clearInterval(gameLoopInterval); // Clear existing interval first
            if (gameRunning && !gamePaused) { // Only set if running and not paused
                const intervalTime = 500 / timeSpeed; // Base interval 0.5 second, adjust by speed
                gameLoopInterval = setInterval(gameTick, intervalTime);
            }
        }

        // --- Tooltip ---
        function updateTooltip(data, mouseX, mouseY) {
            if (!tooltip) return; // Ensure tooltip element exists

            const infectedPercent = data.population > 0 ? ((data.infected / data.population) * 100).toFixed(1) : 0;
            const deadPercent = data.population > 0 ? ((data.dead / data.population) * 100).toFixed(1) : 0;

            tooltip.innerHTML = `
                <strong class="font-semibold text-white">${data.name}</strong>
                <span class="text-xs text-gray-400 block">Pop: ${data.population.toLocaleString()}</span>
                <span class="text-green-400">Healthy: ${Math.round(data.healthy).toLocaleString()}</span>
                <span class="text-red-400 block">Infected: ${Math.round(data.infected).toLocaleString()} (${infectedPercent}%)</span>
                <span class="text-gray-400 block">Dead: ${Math.round(data.dead).toLocaleString()} (${deadPercent}%)</span>
                <span class="text-gray-300 block">Status: ${data.status}</span>
            `;
            updateTooltipPosition(mouseX, mouseY);
        }

        function updateTooltipPosition(mouseX, mouseY) {
             if (!tooltip || !canvasContainer) return;

             // Position tooltip near the cursor, ensuring it stays within viewport bounds
             const tooltipRect = tooltip.getBoundingClientRect();
             // Use window dimensions for boundary checks
             const winWidth = window.innerWidth;
             const winHeight = window.innerHeight;

             let left = mouseX + 15;
             let top = mouseY + 15;

             // Adjust if tooltip goes off-screen right
             if (left + tooltipRect.width > winWidth - 10) { // Add small margin
                 left = mouseX - tooltipRect.width - 15;
             }
             // Adjust if tooltip goes off-screen bottom
             if (top + tooltipRect.height > winHeight - 10) { // Add small margin
                 top = mouseY - tooltipRect.height - 15;
             }
              // Adjust if tooltip goes off-screen left
              if (left < 10) { // Add small margin
                  left = 10;
              }
              // Adjust if tooltip goes off-screen top
              if (top < 10) { // Add small margin
                  top = 10;
              }

             tooltip.style.left = `${left}px`;
             tooltip.style.top = `${top}px`;
        }


         // --- Message Box ---
        let messageTimeout;
        function showMessage(message, duration = 3000) {
            if (!messageBox) return; // Ensure element exists
            clearTimeout(messageTimeout); // Clear previous timeout if any
            messageBox.textContent = message;
            messageBox.classList.add('show');

            messageTimeout = setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }


        // --- Animation Loop ---
        function animate() {
            // Only request next frame if renderer is available
            if (renderer) {
                requestAnimationFrame(animate);

                // Update visuals that change every frame (like node colors)
                // Only update selection color highlight if game hasn't started
                 if (!gameRunning) {
                     updateNodeColors();
                 }

                // Render the scene
                renderer.render(scene, camera);
            }
        }

        // --- Wait for DOM Ready then Initialize ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing simulation...");
            // Assign DOM elements first
            if (assignDOMElements()) {
                // If elements are found, initialize Three.js and the rest
                init();
            } else {
                showMessage("Initialization failed: Could not find required HTML elements.", 10000);
            }
        });

    </script>

</body>
</html>
