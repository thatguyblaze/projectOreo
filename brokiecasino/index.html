<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brokie Casino - Dark Mode</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* General Styles */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #121212; /* Dark Theme Base */
            color: #e0e0e0; /* Light Gray Text */
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }
        .card-bg { background-color: #1e1e1e; } /* Dark Surface */
        .border-color { border-color: #3a3a3a; } /* Subtle Border */
        .border-color-light { border-color: #3a3a3a; } /* Consistent Border */
        .footer-bg { background-color: #1e1e1e; } /* Dark Surface */
        .footer-border { border-color: #3a3a3a; } /* Subtle Border */

        /* Buttons & Inputs */
        button {
            transition: background-color 0.2s ease-in-out, transform 0.1s ease-in-out, box-shadow 0.2s ease-in-out, border-color 0.2s ease-in-out, opacity 0.2s ease-in-out, filter 0.1s ease-in-out;
        }
        button:active:not(:disabled) {
            transform: scale(0.96);
            filter: brightness(0.9);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        /* Hover scale for main action buttons */
        #loan-button:hover:not(:disabled),
        #pay-loan-button:hover:not(:disabled),
        #spin-button:hover:not(:disabled),
        #auto-spin-toggle:hover:not(:disabled),
        #crash-bet-button:hover:not(:disabled),
        #crash-cashout-button:hover:not(:disabled),
        .discord-btn:hover:not(:disabled),
        #atm-modal .atm-button:hover:not(:disabled),
        #coinflip-button:hover:not(:disabled),
        #coinflip-cashout-button:hover:not(:disabled),
        #minefield-start-button:hover:not(:disabled),
        #minefield-cashout-button:hover:not(:disabled),
        .coinflip-choice-btn:hover:not(:disabled),
        #memory-start-button:hover:not(:disabled),
        #horserace-start-button:hover:not(:disabled),
        .horse-select-btn:hover:not(:disabled),
        #roulette-spin-button:hover:not(:disabled),
        .roulette-bet-btn:hover:not(:disabled),
        #blackjack-deal-button:hover:not(:disabled), /* Added Blackjack */
        #blackjack-hit-button:hover:not(:disabled), /* Added Blackjack */
        #blackjack-stand-button:hover:not(:disabled) /* Added Blackjack */
        {
            transform: scale(1.03);
            filter: brightness(1.1); /* Add brightness on hover too */
        }
        input[type="number"], select {
            background-color: #2a2a2a; /* Dark Gray Control BG */
            border: 1px solid #3a3a3a; /* Subtle Border */
            color: #e0e0e0; /* Light Gray Text */
            border-radius: 0.375rem;
            padding: 0.25rem 0.5rem;
            text-align: center;
            -moz-appearance: textfield; /* For number input */
        }
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none; margin: 0;
        }
        input[type="number"]:focus, select:focus {
            --tw-ring-color: #60a5fa; /* Accent Blue */
            border-color: #60a5fa;
            outline: 2px solid transparent;
            outline-offset: 2px;
             box-shadow: 0 0 0 3px rgba(96, 165, 250, 0.5);
        }
        input[type="number"]:disabled, select:disabled { /* General disabled style */
             background-color: #1e1e1e; opacity: 0.6; cursor: not-allowed;
        }
        select { text-align: left; padding-right: 2rem; }
        button:focus-visible {
             outline: 2px solid transparent; outline-offset: 2px;
             --tw-ring-offset-width: 2px; --tw-ring-offset-color: #121212; /* Match body background */
             --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
             --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
             box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
        }
        /* Specific focus ring colors */
        #loan-button:focus-visible { --tw-ring-color: #34d399; }
        #pay-loan-button:focus-visible { --tw-ring-color: #fb923c; }
        #spin-button:focus-visible { --tw-ring-color: #60a5fa; }
        #auto-spin-toggle:focus-visible { --tw-ring-color: #9ca3af; }
        #crash-bet-button:focus-visible { --tw-ring-color: #fcd34d; }
        #crash-cashout-button:focus-visible { --tw-ring-color: #f87171; }
        .discord-btn:focus-visible { --tw-ring-color: #a5b4fc; }
        .atm-button:focus-visible { --tw-ring-color: #9ca3af; }
        .bet-adjust-btn:focus-visible { --tw-ring-color: #9ca3af; }
        #crash-auto-bet-toggle:focus-visible { --tw-ring-color: #9ca3af; }
        #crash-auto-cashout-toggle:focus-visible { --tw-ring-color: #9ca3af; }
        #coinflip-button:focus-visible { --tw-ring-color: #60a5fa; }
        #coinflip-cashout-button:focus-visible { --tw-ring-color: #f87171; }
        #minefield-start-button:focus-visible { --tw-ring-color: #60a5fa; }
        #minefield-cashout-button:focus-visible { --tw-ring-color: #f87171; }
        .coinflip-choice-btn:focus-visible { --tw-ring-color: #9ca3af; }
        #memory-start-button:focus-visible { --tw-ring-color: #ec4899; }
        #horserace-start-button:focus-visible { --tw-ring-color: #84cc16; }
        .horse-select-btn:focus-visible { --tw-ring-color: #9ca3af; }
        .tab-button:focus-visible { --tw-ring-color: #60a5fa; } /* Focus for tab buttons */
        #roulette-spin-button:focus-visible { --tw-ring-color: #10b981; }
        .roulette-bet-btn:focus-visible { --tw-ring-color: #9ca3af; }
        #blackjack-deal-button:focus-visible { --tw-ring-color: #10b981; } /* Added Blackjack */
        #blackjack-hit-button:focus-visible { --tw-ring-color: #60a5fa; } /* Added Blackjack */
        #blackjack-stand-button:focus-visible { --tw-ring-color: #fb923c; } /* Added Blackjack */

        .bet-adjust-btn {
            background-color: #2a2a2a; /* Dark Gray Control BG */
            color: #e0e0e0; padding: 0.25rem 0.5rem; border: 1px solid #3a3a3a; /* Subtle Border */
            border-radius: 0.375rem; font-size: 0.75rem; line-height: 1; min-width: 30px;
        }
        .bet-adjust-btn:hover { background-color: #3a3a3a; }

        /* Toggle Button Base Style */
        .toggle-button {
            padding: 0.5rem 1rem; border: 2px solid #3a3a3a; /* Subtle Border */
            background-color: #2a2a2a; /* Dark Gray Control BG */
            color: #e0e0e0; font-weight: 600; /* Semibold */
            border-radius: 0.375rem; /* rounded-md */ font-size: 0.875rem; /* text-sm */
        }
         .toggle-button:hover { background-color: #3a3a3a; }
         .toggle-button.active {
             background-color: #10b981; /* Emerald 500 */ border-color: #059669; /* Emerald 600 */
             color: white; box-shadow: 0 0 10px rgba(16, 185, 129, 0.5);
         }
         #crash-auto-cashout-toggle.active {
             background-color: #fb923c; /* orange-500 */ border-color: #f97316; /* orange-600 */
         }

        /* Tabs */
        .tab-button { color: #9e9e9e; /* text-gray-400 */ }
        .tab-button:hover { border-color: #3a3a3a; color: #e0e0e0; }
        .tab-button[aria-current="page"] { border-color: #42a5f5; color: #64b5f6; /* Lighter blue variants */ }

        /* Game Area Transition */
        .game-area { transition: opacity 0.3s ease-in-out; }

        /* Message Box */
        #message-box {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%);
            background-color: #2a2a2a; /* Dark Gray Control BG */
            color: #e0e0e0; padding: 1rem 1.5rem; border-radius: 0.5rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5); z-index: 100;
            opacity: 0; visibility: hidden; transition: opacity 0.3s ease, visibility 0.3s ease;
            font-weight: 500;
        }
        #message-box.show { opacity: 1; visibility: visible; }

        /* ATM Modal Styles & Transition */
        #atm-modal-overlay {
            position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.7); z-index: 40;
            transition: opacity 0.3s ease-out;
        }
        #atm-modal-overlay.hidden { opacity: 0; pointer-events: none; }
        #atm-modal {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(1); /* End state */
            background-color: #1e1e1e; /* Dark Surface */
            color: #e0e0e0; padding: 1.5rem 2rem; border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3), 0 4px 6px -4px rgba(0, 0, 0, 0.3);
            z-index: 50; width: 90%; max-width: 400px; border: 1px solid #3a3a3a;
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
        }
         #atm-modal.hidden {
             opacity: 0; transform: translate(-50%, -50%) scale(0.95); /* Start state */
             pointer-events: none;
         }
        #atm-modal h3 { font-size: 1.25rem; font-weight: 600; margin-bottom: 1rem; text-align: center; }
        #atm-modal .atm-button-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 1rem; margin-bottom: 1.5rem; }
        #atm-modal .atm-button {
            background-color: #2a2a2a; /* Dark Gray Control BG */
            color: #e0e0e0; padding: 0.75rem 1rem; border-radius: 0.375rem;
            text-align: center; font-weight: 500; border: 1px solid #3a3a3a;
        }
        #atm-modal .atm-button:hover { background-color: #3a3a3a; }
        #atm-modal .atm-close-button { position: absolute; top: 0.75rem; right: 0.75rem; background: none; border: none; color: #9e9e9e; font-size: 1.5rem; line-height: 1; cursor: pointer; }
        #atm-modal .atm-close-button:hover { color: #e0e0e0; }

        /* Stats & Currency Flash */
        .stats-value { font-weight: 600; font-size: 1.125rem; transition: color 0.3s ease-out; } /* Add transition */
        .text-profit { color: #34d399; }
        .text-loss { color: #f87171; }
        @keyframes flash-green {
            0%, 100% { color: #34d399; transform: scale(1.05); }
            50% { color: #64b5f6; transform: scale(1); } /* Flash to blue */
        }
        @keyframes flash-red {
            0%, 100% { color: #f87171; transform: scale(1.05); }
            50% { color: #64b5f6; transform: scale(1); } /* Flash to blue */
        }
        .flash-win { animation: flash-green 0.6s ease-out; }
        .flash-loss { animation: flash-red 0.6s ease-out; }

        /* Leaderboard & Card Animations */
        @keyframes slideFadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        .leaderboard-entry-new { animation: slideFadeIn 0.5s ease-out; }
        @keyframes cardEnter { from { opacity: 0; transform: translateY(20px); } to { opacity: 1; transform: translateY(0); } }
        .animate-card-enter { opacity: 0; /* Start hidden */ animation: cardEnter 0.5s ease-out forwards; }

        /* Shake Animations */
        @keyframes shake-subtle {
             0%, 100% { transform: translateX(0); } 25% { transform: translateX(-1px); } 75% { transform: translateX(1px); }
        }
        @keyframes shake-strong {
             0%, 100% { transform: translate(0, 0) rotate(0); }
             25% { transform: translate(-2px, 1px) rotate(-0.5deg); }
             50% { transform: translate(1px, -1px) rotate(0.5deg); }
             75% { transform: translate(2px, 1px) rotate(-0.5deg); }
        }
        .shake-subtle { animation: shake-subtle 0.2s infinite linear; }
        .shake-strong { animation: shake-strong 0.15s infinite linear; }

        /* --- Slot Machine Specific --- */
        .reel {
            border: 2px solid #3a3a3a; /* Subtle Border */ background-color: #1e1e1e; /* Dark Surface */
            overflow: hidden; width: 80px; height: 100px; display: flex; flex-direction: column;
            align-items: center; justify-content: center; font-size: 3rem; border-radius: 0.5rem;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5); /* Slightly darker inset */
            color: #e0e0e0; transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .reel.win-effect {
             transform: scale(1.05); box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 0 15px rgba(52, 211, 153, 0.6);
             border-color: #34d399;
        }
        .reel-container { position: relative; height: 100px; overflow: hidden; width: 100%; }
        .reel-symbols { position: absolute; top: 0; left: 0; width: 100%; text-align: center; transition: top 0.5s ease-out; color: #e0e0e0; }
        #payout-legend { margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #3a3a3a; font-size: 0.875rem; color: #9e9e9e; }
         #payout-legend h4 { font-semibold: 600; color: #e0e0e0; margin-bottom: 0.5rem; }
         #payout-legend ul { list-style: none; padding: 0; }
         #payout-legend li { display: flex; justify-content: space-between; padding: 0.25rem 0; }
         #payout-legend li span:first-child { font-family: monospace; margin-right: 1rem; }
         #payout-legend li span:last-child { font-weight: 500; color: #e0e0e0; }

        /* --- Crash Game Specific --- */
        #crash-graph {
            height: 250px; background-color: #1e1e1e; /* Dark Surface */ border-radius: 0.5rem;
            display: flex; align-items: center; justify-content: center; font-size: 2rem; font-weight: bold;
            color: #9e9e9e; /* Slightly lighter gray text */ position: relative; overflow: hidden;
            border: 1px solid #3a3a3a; /* Subtle Border */
        }
        #crash-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 5; }
        #crash-svg .grid-line { stroke: #3a3a3a; stroke-width: 0.5; vector-effect: non-scaling-stroke; }
        #crash-polyline {
            fill: none; stroke: #34d399; /* Green line */ stroke-width: 2.5; stroke-linecap: round;
            stroke-linejoin: round; transition: stroke 0.2s linear; vector-effect: non-scaling-stroke;
            /* filter applied via attribute */
        }
        #crash-multiplier {
            z-index: 10; background-color: rgba(30, 30, 30, 0.8); /* Dark Surface BG */
            color: #e0e0e0; /* Default text color */ padding: 0.3rem 0.8rem; border-radius: 0.375rem;
            transition: transform 0.1s ease, color 0.2s ease-out, font-size 0.2s ease-out; /* Faster transform */
            font-size: 1.75rem; display: inline-block; /* Needed for transform */
        }
         #crash-multiplier.win-effect { transform: scale(1.1); box-shadow: 0 0 15px rgba(52, 211, 153, 0.7); color: #34d399; }
         /* Multiplier Color/Size Classes */
         .mult-color-5x { color: #ffee58; } /* yellow-400 */
         .mult-color-10x { color: #ffa726; } /* orange-400 */
         .mult-color-15x { color: #ff7043; } /* deep-orange-400 */
         .mult-color-20x { color: #ef5350; } /* red-400 */
         .mult-color-30x { color: #ec407a; } /* pink-400 */
         .mult-size-10x { font-size: 1.85rem; }
         .mult-size-20x { font-size: 1.95rem; }
         .mult-size-30x { font-size: 2.05rem; font-weight: 700; }

        /* --- Coin Flip Specific --- */
        .coin-container { /* Add perspective for 3D */
             perspective: 600px; display: inline-block; vertical-align: middle; /* Align with text */
        }
        #coin {
            font-size: 5rem; /* Larger coin */ cursor: default; transition: transform 0.6s;
            transform-style: preserve-3d; display: inline-block;
            /* backface-visibility: hidden; */ /* Keep visible for emoji */
        }
        #coin.flipping { animation: flip 0.6s ease-out; }
        @keyframes flip { /* 3D Flip */
             0% { transform: rotateY(0) rotateX(5deg); }
             50% { transform: rotateY(540deg) rotateX(20deg); }
             100% { transform: rotateY(1080deg) rotateX(0deg); }
        }
        /* Style for selected coin choice */
        .coinflip-choice-btn.selected {
            border-color: #fbbf24; /* amber-400 */ box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
        }

        /* --- Minefield Specific --- */
        #minefield-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 0.5rem; /* gap-2 */
            max-width: 240px; /* Limit width */ margin: 1rem auto; /* Center grid */
        }
        .minefield-tile {
            aspect-ratio: 1 / 1; /* Square tiles */ background-color: #3a3a3a; /* Button background */
            border: 1px solid #4b5563; /* Button border */ border-radius: 0.375rem; /* rounded-md */
            display: flex; align-items: center; justify-content: center; font-size: 1.5rem; /* text-2xl */
            cursor: pointer; transition: background-color 0.2s ease, transform 0.1s ease;
        }
        .minefield-tile:hover:not(.revealed):not(:disabled) { background-color: #4b5563; }
         .minefield-tile:active:not(.revealed):not(:disabled) { transform: scale(0.95); }
        .minefield-tile.revealed.safe {
            background-color: #10b981; /* Emerald 500 */ color: white; cursor: default;
        }
         .minefield-tile.revealed.bomb {
             background-color: #ef4444; /* Red 500 */ color: white; cursor: default;
             animation: shake-strong 0.3s ease-in-out; /* Shake on bomb reveal */
         }
         .minefield-tile:disabled { opacity: 0.7; cursor: not-allowed; }

        /* --- Memory Game Specific --- */
        #memory-grid {
            display: grid; grid-template-columns: repeat(4, 1fr); /* 4x4 Grid */ gap: 0.5rem; /* gap-2 */
            max-width: 280px; /* Adjust width for 4x4 */ margin: 1rem auto; /* Center grid */
            perspective: 1000px; /* For card flip animation */
        }
        .memory-card {
            aspect-ratio: 1 / 1; /* Square cards */ background-color: transparent; border: none;
            border-radius: 0.375rem; /* rounded-md */ display: flex; align-items: center; justify-content: center;
            font-size: 1.75rem; /* Slightly larger emoji */ cursor: pointer; position: relative;
            transform-style: preserve-3d; transition: transform 0.5s ease; /* Only transition transform */
            transform: rotateY(0deg); /* Start face down */
        }
        .memory-card .card-face {
             position: absolute; width: 100%; height: 100%; backface-visibility: hidden; /* Hide back */
             display: flex; align-items: center; justify-content: center; border-radius: 0.375rem;
             transition: background-color 0.2s ease, border-color 0.2s ease; /* Transition colors */
             border: 1px solid #4b5563; /* Add border to faces */
        }
        .memory-card .card-front {
             background-color: #3a3a3a; /* Darker front */ color: #e0e0e0; transform: rotateY(0deg); /* Front face */
        }
        .memory-card .card-back {
             background-color: #2a2a2a; /* Even darker back */ color: #e0e0e0; transform: rotateY(180deg); /* Back face */
        }
        .memory-card.revealed { transform: rotateY(180deg); /* Flip card */ cursor: default; }
        .memory-card.matched { cursor: default; opacity: 0.8; }
        .memory-card.matched .card-back { background-color: #10b981; border-color: #059669; }
        .memory-card.mismatched .card-back {
             background-color: #ef4444; border-color: #dc2626;
             animation: shake-subtle 0.4s ease-in-out; /* Shake on mismatch */
        }
        .memory-card:disabled { cursor: not-allowed; opacity: 0.6; }

        /* --- Horse Race Specific (Right-to-Left) --- */
        #horserace-track {
            position: relative; width: 100%; height: 200px; /* Adjusted height for 4 horses */
            background-color: #2a2a2a; /* Dark track background */ border: 2px solid #3a3a3a;
            border-radius: 0.5rem; overflow: hidden; /* Hide horses if they go past finish line */
            margin-top: 1rem; padding: 0.5rem 0; /* Padding top/bottom for lanes */
            display: flex; /* Use flexbox to arrange lanes */ flex-direction: column; /* Stack lanes vertically */
        }
        .horse-lane {
            width: 100%; flex-grow: 1; /* Make lanes share height equally */
            border-bottom: 1px dashed #4b5563; /* Dashed lane separators */
            display: flex; /* Use flex to align horse vertically */ align-items: center; /* Center horse vertically */
            position: relative; /* Needed for absolute positioning of horse */
        }
        .horse-lane:last-child { border-bottom: none; /* No border on last lane */ }
        .horse {
            position: absolute; /* Position relative to the lane */
            right: 10px; /* Starting position (RIGHT SIDE) */
            font-size: 1.75rem; /* Adjust horse size */
            transition: right 0.1s linear; /* Smooth movement (using RIGHT) */
            padding: 0 5px; line-height: 1; /* Ensure emoji vertical alignment */
            display: inline-block; /* Ensure the div takes space */
            z-index: 5; /* Horse above trail */
            will-change: right; /* Optimize animation (using RIGHT) */
        }
        #horserace-finish-line {
            position: absolute;
            left: 20px; /* Position finish line on the LEFT */
            top: 0; bottom: 0; width: 5px;
            background: repeating-linear-gradient( white, white 10px, black 10px, black 20px );
            z-index: 10;
        }
        /* Horse Trail Styles */
        .horse-trail {
            position: absolute; width: 6px; height: 6px; border-radius: 50%; opacity: 0.7;
            /* background-color handled by JS */
            animation: fadeOutShrink 0.5s linear forwards;
            pointer-events: none; /* Prevent trails interfering with clicks */ z-index: 1; /* Behind horse */
        }
        @keyframes fadeOutShrink {
            from { opacity: 0.7; transform: scale(1) translateY(-50%); }
            to { opacity: 0; transform: scale(0) translateY(-50%); }
        }
        /* Horse Selection Buttons */
        #horserace-selection {
            display: flex; flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 0.5rem; /* space-x-2 equivalent */ justify-content: center; /* Center buttons */
            margin-top: 0.5rem; /* Add some space above buttons */
        }
        .horse-select-btn {
            padding: 0.5rem 1rem; /* py-2 px-4 */ border: 2px solid #4b5563; /* gray-600 */
            border-radius: 0.375rem; /* rounded-md */ font-weight: 600; /* font-semibold */
            font-size: 0.875rem; /* text-sm */ background-color: #3a3a3a; /* gray-700 */
            color: #e0e0e0; /* gray-200 */ display: flex; align-items: center; gap: 0.5rem; /* space-x-2 */
        }
        .horse-select-btn .horse-color-indicator {
            display: inline-block; width: 1rem; /* w-4 */ height: 1rem; /* h-4 */
            border-radius: 9999px; /* rounded-full */ border: 1px solid rgba(255, 255, 255, 0.5); /* Add subtle border */
        }
        .horse-select-btn.selected {
            border-color: #fbbf24; /* amber-400 */ box-shadow: 0 0 8px rgba(251, 191, 36, 0.6);
            background-color: #4b5563; /* gray-600 */
        }

        /* --- Roulette Specific --- */
        #roulette-wheel-container {
            width: 250px; height: 250px; margin: 1rem auto;
            border: 5px solid #4a4a4a; border-radius: 50%;
            position: relative; overflow: hidden;
            background-color: #1a1a1a;
            box-shadow: inset 0 0 15px rgba(0,0,0,0.6);
        }
        #roulette-wheel {
            width: 100%; height: 100%;
            border-radius: 50%;
            position: absolute; top: 0; left: 0;
            transition: transform 4s cubic-bezier(0.3, 0.7, 0.4, 1); /* Spin animation */
            background-image: conic-gradient( /* Simplified visual representation */
                #10b981 0deg 9.7deg, /* Green 0 */
                #ef4444 9.7deg 19.4deg, /* Red */
                #1f2937 19.4deg 29.1deg, /* Black */
                #ef4444 29.1deg 38.8deg, /* Red */
                #1f2937 38.8deg 48.5deg, /* Black */
                #ef4444 48.5deg 58.2deg, /* Red */
                #1f2937 58.2deg 67.9deg, /* Black */
                #ef4444 67.9deg 77.6deg, /* Red */
                #1f2937 77.6deg 87.3deg, /* Black */
                #ef4444 87.3deg 97deg,   /* Red */
                #1f2937 97deg 106.7deg,  /* Black */
                #ef4444 106.7deg 116.4deg, /* Red */
                #1f2937 116.4deg 126.1deg, /* Black */
                #ef4444 126.1deg 135.8deg, /* Red */
                #1f2937 135.8deg 145.5deg, /* Black */
                #ef4444 145.5deg 155.2deg, /* Red */
                #1f2937 155.2deg 164.9deg, /* Black */
                #ef4444 164.9deg 174.6deg, /* Red */
                #1f2937 174.6deg 184.3deg, /* Black */
                #10b981 184.3deg 194deg, /* Green 00 - simplified as second green */
                #1f2937 194deg 203.7deg, /* Black */
                #ef4444 203.7deg 213.4deg, /* Red */
                #1f2937 213.4deg 223.1deg, /* Black */
                #ef4444 223.1deg 232.8deg, /* Red */
                #1f2937 232.8deg 242.5deg, /* Black */
                #ef4444 242.5deg 252.2deg, /* Red */
                #1f2937 252.2deg 261.9deg, /* Black */
                #ef4444 261.9deg 271.6deg, /* Red */
                #1f2937 271.6deg 281.3deg, /* Black */
                #ef4444 281.3deg 291deg,   /* Red */
                #1f2937 291deg 300.7deg,  /* Black */
                #ef4444 300.7deg 310.4deg, /* Red */
                #1f2937 310.4deg 320.1deg, /* Black */
                #ef4444 320.1deg 329.8deg, /* Red */
                #1f2937 329.8deg 339.5deg, /* Black */
                #ef4444 339.5deg 349.2deg, /* Red */
                #1f2937 349.2deg 360deg    /* Black */
            );
        }
        #roulette-pointer {
            position: absolute;
            top: -10px; /* Position above the wheel */
            left: 50%;
            transform: translateX(-50%);
            width: 0; height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 15px solid #facc15; /* Yellow pointer */
            z-index: 10;
        }
         #roulette-result {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 60px; height: 60px;
            background-color: rgba(20, 20, 20, 0.8);
            border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; font-weight: bold;
            color: #fff; z-index: 5;
            border: 3px solid #4a4a4a;
        }
        #roulette-betting-area {
            margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid #3a3a3a;
        }
        .roulette-bet-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr); /* Basic grid for numbers */
            gap: 0.5rem;
            max-width: 300px; margin: 0 auto 1rem auto;
        }
        .roulette-bet-btn {
            padding: 0.5rem; border: 1px solid #4b5563; border-radius: 0.25rem;
            background-color: #3a3a3a; color: #e0e0e0; font-weight: 500;
            text-align: center; font-size: 0.875rem;
        }
        .roulette-bet-btn.red { background-color: #ef4444; color: white; border-color: #dc2626;}
        .roulette-bet-btn.black { background-color: #1f2937; color: white; border-color: #111827;}
        .roulette-bet-btn.green { background-color: #10b981; color: white; border-color: #059669;}
        .roulette-bet-btn.outside { grid-column: span 1; padding: 0.75rem; } /* Style for outside bets */
        .roulette-bet-btn.selected {
             box-shadow: 0 0 0 3px #60a5fa; /* Blue selection indicator */
             filter: brightness(1.2);
        }
        .roulette-outside-bets {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem;
             max-width: 300px; margin: 0 auto;
        }

        /* --- Blackjack Specific --- */
        .blackjack-hand {
            display: flex;
            flex-wrap: wrap; /* Allow cards to wrap */
            justify-content: center; /* Center cards horizontally */
            gap: 0.5rem; /* Space between cards */
            min-height: 90px; /* Ensure space for cards */
            margin-bottom: 1rem; /* Space below hand */
            padding: 0.5rem;
            background-color: #2a2a2a; /* Slightly lighter background for hands */
            border-radius: 0.375rem; /* rounded-md */
            border: 1px solid #3a3a3a;
        }
        .blackjack-card {
            background-color: white;
            color: black;
            border: 1px solid #4b5563; /* gray-600 */
            border-radius: 0.375rem; /* rounded-md */
            width: 60px; /* Card width */
            height: 85px; /* Card height */
            display: flex;
            flex-direction: column;
            justify-content: space-between; /* Space rank and suit */
            align-items: center;
            padding: 0.25rem; /* py-1 */
            font-weight: 600; /* font-semibold */
            font-size: 1rem; /* text-base */
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .blackjack-card.hidden {
            background-color: #3a3a3a; /* Dark gray for hidden card */
            background-image: repeating-linear-gradient(
                45deg,
                #4b5563,
                #4b5563 5px,
                #3a3a3a 5px,
                #3a3a3a 10px
            );
            color: transparent; /* Hide text */
            border-color: #4b5563;
        }
        .blackjack-card span:first-child { /* Rank */
            font-size: 1.25rem; /* text-xl */
            line-height: 1;
        }
        .blackjack-card span:last-child { /* Suit */
            font-size: 1.5rem; /* text-2xl */
            line-height: 1;
        }
        .blackjack-card.suit-red { color: #ef4444; /* red-500 */ }
        .blackjack-card.suit-black { color: #1f2937; /* gray-800 */ }
        .blackjack-score {
            font-weight: 600;
            font-size: 1.125rem; /* text-lg */
            color: #a0aec0; /* gray-400 */
        }
        .blackjack-score-value {
            font-weight: 700;
            font-size: 1.25rem; /* text-xl */
            color: #e0e0e0; /* gray-200 */
            margin-left: 0.5rem;
        }
        .blackjack-score.busted {
            color: #f87171; /* Red for busted */
        }
        .blackjack-score.blackjack {
            color: #fbbf24; /* Amber for blackjack */
        }

    </style>
</head>
<body class="antialiased">

    <header class="card-bg shadow-md">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
            <h1 class="text-3xl font-bold text-white">Brokie Casino</h1>
            <p class="text-gray-400">Where losing feels... affordable?</p>
        </div>
    </header>

    <main class="flex-grow max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 w-full">
        <div class="grid grid-cols-1 md:grid-cols-3 gap-8 main-content-grid">

            <div class="md:col-span-1 space-y-6 grid-col-1">
                <div class="card-bg p-6 rounded-lg shadow-lg animate-card-enter" style="animation-delay: 0s;">
                    <h2 class="text-lg font-semibold mb-2 text-gray-300 pb-1 border-b-2 border-blue-500 inline-block">Your Balance</h2>
                    <p class="text-4xl font-bold text-blue-400 mt-2" id="currency-display">500</p>
                    <p class="text-sm text-gray-400 mt-1">Loan Balance: <span id="loan-balance-display" class="font-medium text-gray-300">0</span></p>
                    <div class="flex space-x-2 mt-4">
                        <button id="loan-button" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-green-500 focus:ring-opacity-75">
                            Get Loan
                        </button>
                        <button id="pay-loan-button" class="flex-1 bg-orange-600 hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-orange-400 focus:ring-opacity-75" disabled>
                            Pay Loan
                        </button>
                    </div>
                </div>
                <div class="card-bg p-6 rounded-lg shadow-lg animate-card-enter" style="animation-delay: 0.05s;">
                    <h2 class="text-lg font-semibold mb-3 text-gray-300 pb-1 border-b-2 border-yellow-500 inline-block">Biggest Wins</h2>
                    <ul id="leaderboard-list" class="space-y-2 text-gray-400 mt-3">
                        <li>No wins yet!</li>
                    </ul>
                </div>
                <div class="card-bg p-6 rounded-lg shadow-lg animate-card-enter" style="animation-delay: 0.1s;">
                    <h2 class="text-lg font-semibold mb-3 text-gray-300 pb-1 border-b-2 border-indigo-500 inline-block">Session Stats</h2>
                    <div class="space-y-2 text-gray-400 mt-3 text-sm">
                        <p>Total Gain: <span id="stats-total-gain" class="stats-value text-profit">0</span></p>
                        <p>Total Loss: <span id="stats-total-loss" class="stats-value text-loss">0</span></p>
                        <p>Net Profit/Loss: <span id="stats-net-profit" class="stats-value">0</span></p>
                    </div>
                </div>
            </div>

            <div class="md:col-span-2 space-y-8 grid-col-2">
                <div class="mb-4 border-b border-color animate-card-enter" style="animation-delay: 0.15s;">
                    <nav class="-mb-px flex space-x-6 overflow-x-auto" aria-label="Tabs">
                         <button id="tab-slots" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm" aria-current="page">
                             Slot Machine
                         </button>
                         <button id="tab-crash" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                             Crash Game
                         </button>
                         <button id="tab-coinflip" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                             Coin Flip
                         </button>
                         <button id="tab-minefield" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                             Minefield
                         </button>
                         <button id="tab-memory" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                             Memory
                         </button>
                         <button id="tab-horserace" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                             Horse Race
                         </button>
                         <button id="tab-roulette" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                             Roulette
                         </button>
                         <button id="tab-blackjack" class="tab-button whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm">
                            Blackjack
                        </button>
                    </nav>
                </div>

                <div id="game-slots" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 relative animate-card-enter" style="animation-delay: 0.2s;">
                    <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-red-500 inline-block">Spin to Win!</h3>
                    <div class="flex justify-center space-x-4 pt-4">
                        <div class="reel"><div class="reel-container"><div class="reel-symbols" id="reel1">❓</div></div></div>
                        <div class="reel"><div class="reel-container"><div class="reel-symbols" id="reel2">❓</div></div></div>
                        <div class="reel"><div class="reel-container"><div class="reel-symbols" id="reel3">❓</div></div></div>
                    </div>
                    <div class="flex items-center justify-center space-x-2 mt-4">
                        <label for="slot-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                        <button class="bet-adjust-btn" id="slot-bet-decrease-10">-10</button>
                        <button class="bet-adjust-btn" id="slot-bet-decrease-1">-</button>
                        <input type="number" id="slot-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400 appearance-none">
                        <button class="bet-adjust-btn" id="slot-bet-increase-1">+</button>
                        <button class="bet-adjust-btn" id="slot-bet-increase-10">+10</button>
                    </div>
                    <div class="flex items-center justify-center space-x-2 mt-2">
                         <button class="bet-adjust-btn" id="slot-bet-min">Min</button>
                         <button class="bet-adjust-btn" id="slot-bet-half">/2</button>
                         <button class="bet-adjust-btn" id="slot-bet-double">x2</button>
                         <button class="bet-adjust-btn" id="slot-bet-max">Max</button>
                    </div>
                    <div class="flex items-center justify-center space-x-4 mt-6">
                        <button id="spin-button" class="w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
                            Spin
                        </button>
                        <button id="auto-spin-toggle" class="toggle-button w-auto text-white font-bold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-gray-400 focus:ring-opacity-75">
                            Auto Off
                        </button>
                    </div>
                    <div id="payout-legend">
                        <h4>Payouts (Multiplier x Bet)</h4>
                        <ul id="payout-list">
                        </ul>
                    </div>
                </div>

                <div id="game-crash" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 hidden animate-card-enter" style="animation-delay: 0.2s;">
                     <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-green-500 inline-block">Cash Out Before the Crash!</h3>
                     <div id="crash-graph" class="relative mt-4">
                           <svg id="crash-svg" preserveAspectRatio="none">
                               <defs>
                                   <filter id="line-shadow" x="-50%" y="-50%" width="200%" height="200%">
                                       <feDropShadow dx="1" dy="2" stdDeviation="1.5" flood-color="#059669" flood-opacity="0.6"/>
                                   </filter>
                               </defs>
                               <g id="crash-grid"></g>
                               <polyline id="crash-polyline" filter="url(#line-shadow)" points="0,100"></polyline>
                           </svg>
                          <span id="crash-multiplier" class="text-gray-300">1.00x</span>
                     </div>
                     <div class="flex items-center justify-center space-x-2 mt-4">
                          <label for="crash-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                          <button class="bet-adjust-btn" id="crash-bet-decrease-10">-10</button>
                          <button class="bet-adjust-btn" id="crash-bet-decrease-1">-</button>
                          <input type="number" id="crash-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400">
                          <button class="bet-adjust-btn" id="crash-bet-increase-1">+</button>
                          <button class="bet-adjust-btn" id="crash-bet-increase-10">+10</button>
                     </div>
                     <div class="flex items-center justify-center space-x-2 mt-2">
                           <button class="bet-adjust-btn" id="crash-bet-min">Min</button>
                           <button class="bet-adjust-btn" id="crash-bet-half">/2</button>
                           <button class="bet-adjust-btn" id="crash-bet-double">x2</button>
                           <button class="bet-adjust-btn" id="crash-bet-max">Max</button>
                     </div>
                     <div class="flex flex-col sm:flex-row items-center justify-center space-y-3 sm:space-y-0 sm:space-x-4 mt-4">
                          <button id="crash-bet-button" class="w-full sm:w-auto bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-amber-300 focus:ring-opacity-75">
                              Place Bet
                          </button>
                           <button id="crash-cashout-button" class="w-full sm:w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-red-400 focus:ring-opacity-75 disabled:opacity-50" disabled>
                               Cash Out
                           </button>
                     </div>
                     <div class="flex flex-col sm:flex-row items-center justify-center space-y-3 sm:space-y-0 sm:space-x-4 mt-4 border-t border-color pt-4">
                          <button id="crash-auto-bet-toggle" class="toggle-button w-full sm:w-auto">Auto Bet Off</button>
                          <div class="flex items-center space-x-2">
                              <label for="crash-auto-cashout-input" class="text-sm font-medium text-gray-400">Auto Cashout @</label>
                              <input type="number" id="crash-auto-cashout-input" min="1.01" step="0.01" placeholder="1.50" class="w-20 text-sm auto-cashout-input">
                              <button id="crash-auto-cashout-toggle" class="toggle-button text-sm !py-1 !px-3">Enable</button>
                          </div>
                     </div>
                     <p id="crash-status" class="text-center text-gray-400 font-medium h-6"></p>
                </div>

                <div id="game-coinflip" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 hidden animate-card-enter" style="animation-delay: 0.2s;">
                    <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-yellow-400 inline-block">Coin Flip: Double or Nothing!</h3>
                     <div class="text-center my-6 coin-container">
                          <span id="coin" class="text-6xl">🪙</span>
                     </div>
                     <div class="flex items-center justify-center space-x-2 mt-4">
                          <label for="coinflip-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                          <button class="bet-adjust-btn" id="coinflip-bet-decrease-10">-10</button>
                          <button class="bet-adjust-btn" id="coinflip-bet-decrease-1">-</button>
                          <input type="number" id="coinflip-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400 appearance-none">
                          <button class="bet-adjust-btn" id="coinflip-bet-increase-1">+</button>
                          <button class="bet-adjust-btn" id="coinflip-bet-increase-10">+10</button>
                     </div>
                     <div class="flex items-center justify-center space-x-2 mt-2">
                           <button class="bet-adjust-btn" id="coinflip-bet-min">Min</button>
                           <button class="bet-adjust-btn" id="coinflip-bet-half">/2</button>
                           <button class="bet-adjust-btn" id="coinflip-bet-double">x2</button>
                           <button class="bet-adjust-btn" id="coinflip-bet-max">Max</button>
                     </div>
                     <div class="flex items-center justify-center space-x-4 mt-4">
                           <button id="coinflip-choose-blue" class="coinflip-choice-btn flex-1 bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
                               Choose Blue 🔵
                           </button>
                           <button id="coinflip-choose-yellow" class="coinflip-choice-btn flex-1 bg-yellow-500 hover:bg-yellow-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-yellow-300 focus:ring-opacity-75">
                               Choose Yellow 🟡
                           </button>
                     </div>
                     <div class="flex items-center justify-center space-x-4 mt-6">
                          <button id="coinflip-button" class="w-auto bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-indigo-400 focus:ring-opacity-75" disabled>
                              Select Side & Flip
                          </button>
                           <button id="coinflip-cashout-button" class="w-auto bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-red-400 focus:ring-opacity-75 disabled:opacity-50" disabled>
                              Cash Out <span id="coinflip-winnings">0</span>
                           </button>
                     </div>
                     <p id="coinflip-status" class="text-center text-gray-400 font-medium h-6"></p>
                </div>

                <div id="game-minefield" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 hidden animate-card-enter" style="animation-delay: 0.2s;">
                    <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-orange-500 inline-block">Minefield</h3>
                     <div class="flex items-center justify-center space-x-2 mt-4">
                          <label for="minefield-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                          <button class="bet-adjust-btn" id="minefield-bet-decrease-10">-10</button>
                          <button class="bet-adjust-btn" id="minefield-bet-decrease-1">-</button>
                          <input type="number" id="minefield-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400 appearance-none">
                          <button class="bet-adjust-btn" id="minefield-bet-increase-1">+</button>
                          <button class="bet-adjust-btn" id="minefield-bet-increase-10">+10</button>
                     </div>
                     <div class="flex items-center justify-center space-x-2 mt-2">
                           <button class="bet-adjust-btn" id="minefield-bet-min">Min</button>
                           <button class="bet-adjust-btn" id="minefield-bet-half">/2</button>
                           <button class="bet-adjust-btn" id="minefield-bet-double">x2</button>
                           <button class="bet-adjust-btn" id="minefield-bet-max">Max</button>
                     </div>
                     <div id="minefield-grid">
                         </div>
                     <div class="flex items-center justify-center space-x-4 mt-6">
                          <button id="minefield-start-button" class="w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
                              Start Game
                          </button>
                           <button id="minefield-cashout-button" class="w-auto bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-green-500 focus:ring-opacity-75 disabled:opacity-50" disabled>
                              Cash Out (<span id="minefield-current-multiplier">1.00</span>x)
                           </button>
                     </div>
                     <p id="minefield-status" class="text-center text-gray-400 font-medium h-6"></p>
                </div>

                <div id="game-memory" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 hidden animate-card-enter" style="animation-delay: 0.2s;">
                      <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-pink-500 inline-block">Memory Match</h3>
                      <div class="flex items-center justify-center space-x-2 mt-4">
                          <label for="memory-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                          <button class="bet-adjust-btn" id="memory-bet-decrease-10">-10</button>
                          <button class="bet-adjust-btn" id="memory-bet-decrease-1">-</button>
                          <input type="number" id="memory-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400 appearance-none">
                          <button class="bet-adjust-btn" id="memory-bet-increase-1">+</button>
                          <button class="bet-adjust-btn" id="memory-bet-increase-10">+10</button>
                      </div>
                      <div class="flex items-center justify-center space-x-2 mt-2">
                           <button class="bet-adjust-btn" id="memory-bet-min">Min</button>
                           <button class="bet-adjust-btn" id="memory-bet-half">/2</button>
                           <button class="bet-adjust-btn" id="memory-bet-double">x2</button>
                           <button class="bet-adjust-btn" id="memory-bet-max">Max</button>
                      </div>
                      <div id="memory-grid">
                          </div>
                      <div class="flex flex-col sm:flex-row items-center justify-center space-y-2 sm:space-y-0 sm:space-x-4 mt-6">
                           <button id="memory-start-button" class="w-auto bg-pink-600 hover:bg-pink-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-pink-400 focus:ring-opacity-75">
                               Start Game
                           </button>
                           <div class="text-gray-300 text-sm">
                               Tries Left: <span id="memory-tries-left" class="font-bold">--</span>
                           </div>
                      </div>
                      <p id="memory-status" class="text-center text-gray-400 font-medium h-6"></p>
                </div>

                <div id="game-horserace" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 hidden animate-card-enter" style="animation-delay: 0.2s;">
                    <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-lime-500 inline-block">Horse Racing</h3>
                    <div class="flex flex-col space-y-4">
                        <div class="flex flex-col sm:flex-row items-center justify-center gap-2 flex-wrap">
                            <label for="horserace-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                            <div class="flex items-center justify-center space-x-2">
                                <button class="bet-adjust-btn" id="horserace-bet-decrease-10">-10</button>
                                <button class="bet-adjust-btn" id="horserace-bet-decrease-1">-</button>
                                <input type="number" id="horserace-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400 appearance-none">
                                <button class="bet-adjust-btn" id="horserace-bet-increase-1">+</button>
                                <button class="bet-adjust-btn" id="horserace-bet-increase-10">+10</button>
                            </div>
                             <div class="flex items-center justify-center space-x-2">
                                  <button class="bet-adjust-btn" id="horserace-bet-min">Min</button>
                                  <button class="bet-adjust-btn" id="horserace-bet-half">/2</button>
                                  <button class="bet-adjust-btn" id="horserace-bet-double">x2</button>
                                  <button class="bet-adjust-btn" id="horserace-bet-max">Max</button>
                             </div>
                        </div>
                        <div>
                             <label class="block text-center font-medium text-gray-300 text-sm mb-2">Pick Your Horse:</label>
                             <div id="horserace-selection" class="flex flex-wrap gap-2 justify-center">
                                 </div>
                        </div>
                    </div>
                    <div id="horserace-track">
                         </div>
                    <div class="flex items-center justify-center space-x-4 mt-6">
                         <button id="horserace-start-button" class="w-auto bg-lime-600 hover:bg-lime-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-lime-400 focus:ring-opacity-75">
                             Start Race
                         </button>
                    </div>
                    <p id="horserace-status" class="text-center text-gray-400 font-medium h-6"></p>
                </div>

                <div id="game-roulette" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 hidden animate-card-enter" style="animation-delay: 0.2s;">
                    <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-purple-500 inline-block">Roulette</h3>

                    <div id="roulette-wheel-container">
                        <div id="roulette-wheel"></div>
                        <div id="roulette-pointer"></div>
                        <div id="roulette-result">?</div>
                    </div>

                    <div class="flex items-center justify-center space-x-2 mt-4">
                        <label for="roulette-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                        <button class="bet-adjust-btn" id="roulette-bet-decrease-10">-10</button>
                        <button class="bet-adjust-btn" id="roulette-bet-decrease-1">-</button>
                        <input type="number" id="roulette-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400 appearance-none">
                        <button class="bet-adjust-btn" id="roulette-bet-increase-1">+</button>
                        <button class="bet-adjust-btn" id="roulette-bet-increase-10">+10</button>
                    </div>
                    <div class="flex items-center justify-center space-x-2 mt-2">
                        <button class="bet-adjust-btn" id="roulette-bet-min">Min</button>
                        <button class="bet-adjust-btn" id="roulette-bet-half">/2</button>
                        <button class="bet-adjust-btn" id="roulette-bet-double">x2</button>
                        <button class="bet-adjust-btn" id="roulette-bet-max">Max</button>
                    </div>

                    <div id="roulette-betting-area">
                        <p class="text-center text-gray-400 text-sm mb-2">Click to place bets (Current Bet: <span id="roulette-current-bet-type">None</span>)</p>
                        <div class="roulette-bet-grid" id="roulette-inside-bets">
                            </div>
                        <div class="roulette-outside-bets mt-4" id="roulette-outside-bets">
                            <button class="roulette-bet-btn outside red" data-bet-type="red">Red</button>
                            <button class="roulette-bet-btn outside black" data-bet-type="black">Black</button>
                            <button class="roulette-bet-btn outside" data-bet-type="odd">Odd</button>
                            <button class="roulette-bet-btn outside" data-bet-type="even">Even</button>
                            <button class="roulette-bet-btn outside" data-bet-type="low">1-18</button>
                            <button class="roulette-bet-btn outside" data-bet-type="high">19-36</button>
                        </div>
                    </div>

                    <div class="flex items-center justify-center space-x-4 mt-6">
                        <button id="roulette-spin-button" class="w-auto bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-emerald-400 focus:ring-opacity-75">
                            Spin Wheel
                        </button>
                    </div>
                    <p id="roulette-status" class="text-center text-gray-400 font-medium h-6"></p>
                </div>

                <div id="game-blackjack" class="game-area card-bg p-6 rounded-lg shadow-lg space-y-6 hidden animate-card-enter" style="animation-delay: 0.2s;">
                    <h3 class="text-xl font-semibold text-gray-100 pb-1 border-b-2 border-gray-500 inline-block">Blackjack</h3>

                    <div class="mb-4">
                        <h4 class="text-lg font-medium text-gray-400 mb-2 text-center">Dealer's Hand (<span id="blackjack-dealer-score" class="blackjack-score-value">0</span>)</h4>
                        <div id="blackjack-dealer-hand" class="blackjack-hand">
                            </div>
                    </div>

                    <div class="mb-6">
                        <h4 class="text-lg font-medium text-gray-400 mb-2 text-center">Your Hand (<span id="blackjack-player-score" class="blackjack-score-value">0</span>)</h4>
                        <div id="blackjack-player-hand" class="blackjack-hand">
                            </div>
                    </div>

                    <div class="flex items-center justify-center space-x-2 mt-4">
                        <label for="blackjack-bet" class="font-medium text-gray-300 text-sm">Bet:</label>
                        <button class="bet-adjust-btn" id="blackjack-bet-decrease-10">-10</button>
                        <button class="bet-adjust-btn" id="blackjack-bet-decrease-1">-</button>
                        <input type="number" id="blackjack-bet" value="10" min="1" class="w-20 border-color-light rounded-md focus:ring-blue-400 focus:border-blue-400 appearance-none">
                        <button class="bet-adjust-btn" id="blackjack-bet-increase-1">+</button>
                        <button class="bet-adjust-btn" id="blackjack-bet-increase-10">+10</button>
                    </div>
                    <div class="flex items-center justify-center space-x-2 mt-2">
                        <button class="bet-adjust-btn" id="blackjack-bet-min">Min</button>
                        <button class="bet-adjust-btn" id="blackjack-bet-half">/2</button>
                        <button class="bet-adjust-btn" id="blackjack-bet-double">x2</button>
                        <button class="bet-adjust-btn" id="blackjack-bet-max">Max</button>
                    </div>

                    <div class="flex items-center justify-center space-x-4 mt-6">
                        <button id="blackjack-deal-button" class="w-auto bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-emerald-400 focus:ring-opacity-75">
                            Deal
                        </button>
                        <button id="blackjack-hit-button" class="w-auto bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75" disabled>
                            Hit
                        </button>
                        <button id="blackjack-stand-button" class="w-auto bg-orange-600 hover:bg-orange-700 text-white font-bold py-2 px-6 rounded-lg shadow-md focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-orange-400 focus:ring-opacity-75" disabled>
                            Stand
                        </button>
                    </div>

                    <p id="blackjack-status" class="text-center text-gray-400 font-medium h-6"></p>
                </div>


            </div> </div> <div class="mt-12 card-bg p-6 rounded-lg shadow-lg grid-col-about animate-card-enter" style="animation-delay: 0.25s;">
            <h2 class="text-2xl font-semibold mb-4 text-gray-100 pb-1 border-b-2 border-purple-500 inline-block">Why Brokie Casino?</h2>
             <p class="text-gray-400 leading-relaxed mt-3">
                  Ever get the itch to watch numbers go brrr without your wallet crying? Yeah, us too.
                  Brokie Casino is basically that: a place to click buttons and chase multipliers, zero real-world stakes attached.
             </p>
             <p class="text-gray-400 leading-relaxed mt-3">
                  Spin some slots, try not to get rekt in Crash, flip a coin, sweep for mines, test your memory, bet on the ponies, try your luck at Roulette, or hit 21 in Blackjack. If you bottom out? Just hit the ATM. Think of it as stress relief, but with slightly more degenerate energy.
             </p>
             <a href="https://discord.gg/placeholder" target="_blank" rel="noopener noreferrer"
                class="inline-block discord-btn font-semibold py-2 px-5 rounded-lg shadow-md mt-4 focus:outline-none focus:ring-offset-2 focus:ring-offset-black focus:ring-2 focus:ring-indigo-300 focus:ring-opacity-75">
                 Join the Discord Community
             </a>
        </div>
    </main>

    <footer class="footer-bg mt-auto border-t footer-border">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 text-center text-gray-500 text-sm">
            Made with 💖 by Blazinik
        </div>
    </footer>

    <div id="message-box">This is a message!</div>

    <div id="atm-modal-overlay" class="hidden"></div>
    <div id="atm-modal" class="hidden">
        <button id="atm-close-button" class="atm-close-button">&times;</button>
        <h3>Brokie ATM</h3>
        <p class="text-sm text-gray-400 mb-4 text-center">Select withdrawal amount:</p>
        <div class="atm-button-grid">
            <button class="atm-button" data-amount="50">50</button>
            <button class="atm-button" data-amount="100">100</button>
            <button class="atm-button" data-amount="250">250</button>
            <button class="atm-button" data-amount="500">500</button>
        </div>
    </div>

    <script>
        // --- Global State ---
        let currency = 500;
        let totalLoanAmount = 0;
        let leaderboard = [];
        let totalGain = 0;
        let totalLoss = 0;
        const MAX_LEADERBOARD_ENTRIES = 5;
        let animationFrameId = null; // For requestAnimationFrame cleanup

        // --- Slot Machine ---
        const slotSymbols = ['🍒', '🍋', '🍊', '🍉', '🔔', '💎', '💰', '7️⃣'];
        const slotPayouts = {
            '7️⃣7️⃣7️⃣': 250, '💰💰💰': 100, '💎💎💎': 90, '🔔🔔🔔': 60,
            '🍉🍉🍉': 25, '🍊🍊🍊': 20, '🍋🍋🍋': 15, '🍒🍒🍒': 10,
            '7️⃣7️⃣': 10, '💰💰': 7, '💎💎': 5, '🍒🍒': 2, // Allow 2 symbols win only for specific ones if desired
        };
        const SPIN_DURATION = 1000; // ms for reel spin animation
        const REEL_SPIN_OFFSET = 1500; // px, how far the reel strip scrolls visually
        let isAutoSpinning = false;
        let slotSpinTimeout = null; // Timeout for auto-spin delay

        // --- Crash Game ---
        let crashGameActive = false;
        let crashMultiplier = 1.00;
        let crashTargetMultiplier = 1.00;
        let crashInterval = null; // For the game loop
        let crashPlayerBet = 0;
        let crashCashedOut = false;
        let crashTimeStep = 0; // Counter for x-axis progression
        const CRASH_UPDATE_INTERVAL = 100; // ms interval for game loop
        const INITIAL_VIEWBOX_WIDTH = 100; // Initial SVG viewbox width
        const INITIAL_VIEWBOX_HEIGHT = 100; // Initial SVG viewbox height
        let currentViewBox = { x: 0, y: 0, width: INITIAL_VIEWBOX_WIDTH, height: INITIAL_VIEWBOX_HEIGHT };
        const VIEWBOX_PAN_THRESHOLD = 0.5; // Pan when point crosses 50% width/height
        const CRASH_Y_SCALING_FACTOR = 15; // How fast line moves up vertically relative to multiplier
        let isCrashAutoBetting = false;
        let isAutoCashoutEnabled = false;
        let autoCashoutTarget = 0;

        // --- Coin Flip ---
        let coinFlipActive = false; // Is a round currently in progress (after first bet)?
        let coinFlipBet = 0; // The initial bet amount for the round
        let currentCoinFlipWinnings = 0; // The amount currently staked (doubles on win)
        let isCoinFlipping = false; // Is the coin animation currently playing?
        let coinFlipChoice = null; // 'blue' or 'yellow'

        // --- Minefield ---
        let minefieldActive = false;
        let minefieldBet = 0;
        let minefieldGrid = []; // Stores 0 for safe, 1 for bomb
        let minefieldRevealed = []; // Stores true/false for revealed tiles
        const MINEFIELD_SIZE = 4; // 4x4 grid
        const MINEFIELD_TILES = MINEFIELD_SIZE * MINEFIELD_SIZE;
        const MINEFIELD_BOMBS = 3; // Number of bombs
        let minefieldSafePicks = 0; // How many safe tiles revealed this round
        let minefieldMultiplier = 1.0;
        // Multipliers for consecutive safe picks
        const MINEFIELD_MULTIPLIERS = [
            1.00, 1.25, 1.60, 2.25, 2.70, 3.25, 4.00, 5.00, 6.50, 8.50, 11.00, 15.00 // Max 13 safe picks (16 tiles - 3 bombs)
        ];

        // --- Memory Game ---
        let memoryActive = false;
        let memoryBet = 0;
        const MEMORY_GRID_SIZE = 4; // 4x4 grid
        const MEMORY_CARDS = MEMORY_GRID_SIZE * MEMORY_GRID_SIZE; // 16 cards
        const MEMORY_PAIRS = MEMORY_CARDS / 2; // 8 pairs
        const MEMORY_SYMBOLS = ['🍎','🍌','🍇','🍓','🥝','🍍','🍑','🥥']; // 8 symbols for pairs
        let memoryGridSymbols = []; // Actual symbols placed on the grid
        let memoryRevealedCards = []; // Indices of currently revealed cards (max 2)
        let memoryMatchedIndices = []; // Indices of cards that have been matched
        let memoryTriesLeft = 0;
        const MEMORY_INITIAL_TRIES = 10; // Number of attempts allowed
        const MEMORY_WIN_MULTIPLIER = 3; // Payout multiplier on win
        let memoryIsChecking = false; // Flag to prevent clicks during check animation/delay

        // --- Horse Race Game (Right-to-Left) ---
        let horseraceActive = false;
        let horseraceBet = 0;
        let selectedHorseIndex = -1; // Index of the selected horse (0-3)
        let raceAnimationId = null; // ID for requestAnimationFrame
        let horsePositions = []; // Array to store current pixel position (from right edge) of each horse
        let horseLaneElements = []; // Store references to lane elements
        const NUM_HORSES = 4;
        const HORSE_NAMES = ["Panda", "Quinton", "Blaze", "Matt"];
        const HORSERACE_WIN_MULTIPLIER = 5; // Payout for winning horse (adjust as needed)
        const HORSE_COLORS = ['#ef4444', '#f97316', '#3b82f6', '#a855f7']; // red, orange, blue, purple
        let raceFrameCounter = 0; // Counter for trail generation

        // --- Roulette Game ---
        let rouletteActive = false; // Is the wheel spinning? (Corrected variable name)
        let rouletteBet = 0; // Current bet amount per spin
        let rouletteSelectedBet = null; // { type: 'number'/'red'/'black'/'odd'/'even'/'low'/'high', value: number | null }
        let rouletteIsSpinning = false; // Flag specifically for animation state
        const ROULETTE_NUMBERS = [0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26]; // Standard European order
        const ROULETTE_NUMBER_COLORS = {}; // Will be populated in init
        const ROULETTE_SPIN_DURATION = 4000; // ms for wheel spin animation
        let currentWheelAngle = 0; // Tracks the visual rotation state

        // --- Blackjack Game ---
        let blackjackActive = false; // Is a game currently in progress?
        let blackjackBet = 0; // Current bet amount
        let blackjackDeck = []; // Array to hold the current deck of cards
        let blackjackPlayerHand = []; // Array of player's cards
        let blackjackDealerHand = []; // Array of dealer's cards
        let blackjackPlayerScore = 0; // Player's current score
        let blackjackDealerScore = 0; // Dealer's current score (visible part)
        let blackjackPlayerBusted = false;
        let blackjackDealerBusted = false;
        let blackjackPlayerBlackjack = false;
        let blackjackDealerBlackjack = false;
        const BLACKJACK_PAYOUT_MULTIPLIER = 2.5; // 3:2 payout for Blackjack (1.5 profit + original bet)
        const REGULAR_WIN_MULTIPLIER = 2.0; // 1:1 payout for regular win (1 profit + original bet)
        const BLACKJACK_TARGET_SCORE = 21;
        const DEALER_STAND_SCORE = 17;
        const blackjackSuits = ['♠', '♥', '♦', '♣'];
        const blackjackRanks = ['2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K', 'A'];


        // --- Sound ---
        let toneStarted = false;
        // Function to initialize Tone.js on user interaction
        async function startTone() {
            if (!toneStarted) {
                try {
                    await Tone.start();
                    console.log("AudioContext started successfully.");
                    toneStarted = true;
                } catch (e) {
                    console.error("Failed to start AudioContext:", e);
                    // Optionally show a message to the user that sound won't work
                }
            }
        }

        // Create synth instances (consider creating them after Tone.start() if issues arise)
        const synth = new Tone.Synth().toDestination();
        const polySynth = new Tone.PolySynth(Tone.Synth).toDestination();
        polySynth.volume.value = -8; // Adjust volume
        const noiseSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.01, decay: 0.1, sustain: 0 } }).toDestination();
        noiseSynth.volume.value = -20; // Adjust volume

        // Function to play different sound effects
        function playSound(type, value = 0) {
            if (!toneStarted) return; // Don't play if Tone hasn't started
            const now = Tone.now();
            try {
                // Added 'index' as a parameter for sounds needing it (like reel stop)
                let index = typeof value === 'object' && value !== null && value.index !== undefined ? value.index : 0;

                switch (type) {
                    case 'win_small': polySynth.triggerAttackRelease(["C4", "E4", "G4"], "8n", now); break;
                    case 'win_medium': polySynth.triggerAttackRelease(["C5", "E5", "G5"], "4n", now); break;
                    case 'win_big': polySynth.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5", "G5"], "2n", now); break; // More complex big win
                    case 'lose': synth.triggerAttackRelease("C3", "4n", now); break; // Simple lose sound
                    case 'loan': synth.triggerAttackRelease("A4", "8n", now); break;
                    case 'click': synth.triggerAttackRelease("C5", "16n", now + 0.01); break; // Subtle click for buttons/bets
                    case 'spin_start': noiseSynth.triggerAttackRelease("8n", now); break; // Slot spin start
                    case 'reel_stop': synth.triggerAttackRelease("A3", "16n", now + index * 0.05); break; // Slot reel stop (use index)

                    case 'crash_tick': if (value > 5) synth.triggerAttackRelease("E6", "32n", now); else if (value > 5) synth.triggerAttackRelease("C6", "32n", now); break; // Crash multiplier tick
                    case 'crash_cashout': polySynth.triggerAttackRelease(["G4", "C5", "E5"], "4n", now); break;
                    case 'crash_explode': polySynth.triggerAttackRelease(["C2", "E2", "G#2"], "2n", now); noiseSynth.triggerAttackRelease("2n", now + 0.05); break; // Crash explosion

                    case 'coin_flip': synth.triggerAttackRelease("A4", "16n", now); break; // Simple flip sound

                    case 'mine_reveal': synth.triggerAttackRelease("C5", "16n", now + 0.02); break; // Subtle reveal
                    case 'mine_bomb': polySynth.triggerAttackRelease(["C3", "D#3", "A3"], "4n", now); break; // Bomb hit sound

                    case 'memory_flip': synth.triggerAttackRelease("E5", "16n", now + 0.01); break; // Card flip sound
                    case 'memory_match': polySynth.triggerAttackRelease(["C5", "G5"], "8n", now); break; // Match sound
                    case 'memory_mismatch': synth.triggerAttackRelease("A3", "8n", now); break; // Mismatch sound
                    case 'memory_win': polySynth.triggerAttackRelease(["C4", "E4", "G4", "C5", "E5"], "2n", now); break; // Memory win sound
                    case 'memory_lose': polySynth.triggerAttackRelease(["C3", "E3", "G3"], "2n", now); break; // Memory lose sound

                    case 'race_start': noiseSynth.triggerAttackRelease("4n", now); break; // Race start sound
                    case 'race_win': polySynth.triggerAttackRelease(["C4", "G4", "C5", "E5"], "1n", now); break; // Race win sound
                    case 'race_step': noiseSynth.triggerAttackRelease("64n", now); break; // Subtle horse step

                    case 'roulette_spin': noiseSynth.triggerAttackRelease("1n", now); break; // Roulette wheel spin
                    case 'roulette_ball': synth.triggerAttackRelease("G5", "32n", now); break; // Roulette ball bounce (can be repeated)
                    case 'roulette_win': polySynth.triggerAttackRelease(["D4", "F#4", "A4", "D5"], "2n", now); break; // Roulette win

                    // Blackjack Sounds
                    case 'blackjack_deal': polySynth.triggerAttackRelease(["C4", "E4"], "16n", now); break; // Quick deal sound
                    case 'blackjack_hit': synth.triggerAttackRelease("D4", "16n", now + 0.01); break; // Single card hit
                    case 'blackjack_bust': synth.triggerAttackRelease("A2", "4n", now); break; // Bust sound
                    case 'blackjack_win': polySynth.triggerAttackRelease(["C4", "G4", "C5"], "4n", now); break; // Regular win
                    case 'blackjack_push': synth.triggerAttackRelease("E4", "8n", now); break; // Push sound
                    case 'blackjack_blackjack': polySynth.triggerAttackRelease(["C4", "E4", "G4", "C5"], "2n", now); break; // Blackjack win sound

                }
            } catch (error) {
                console.error("Tone.js error playing sound:", error);
            }
        }


        // --- DOM Elements ---
        const currencyDisplay = document.getElementById('currency-display');
        const loanBalanceDisplay = document.getElementById('loan-balance-display');
        const loanButton = document.getElementById('loan-button');
        const payLoanButton = document.getElementById('pay-loan-button');
        const leaderboardList = document.getElementById('leaderboard-list');
        const messageBox = document.getElementById('message-box');
        // Tabs & Game Areas
        const tabSlots = document.getElementById('tab-slots');
        const tabCrash = document.getElementById('tab-crash');
        const tabCoinflip = document.getElementById('tab-coinflip');
        const tabMinefield = document.getElementById('tab-minefield');
        const tabMemory = document.getElementById('tab-memory');
        const tabHorserace = document.getElementById('tab-horserace');
        const tabRoulette = document.getElementById('tab-roulette');
        const tabBlackjack = document.getElementById('tab-blackjack'); // New Blackjack Tab
        const gameSlots = document.getElementById('game-slots');
        const gameCrash = document.getElementById('game-crash');
        const gameCoinflip = document.getElementById('game-coinflip');
        const gameMinefield = document.getElementById('game-minefield');
        const gameMemory = document.getElementById('game-memory');
        const gameHorserace = document.getElementById('game-horserace');
        const gameRoulette = document.getElementById('game-roulette');
        const gameBlackjack = document.getElementById('game-blackjack'); // New Blackjack Area
        const allTabs = [tabSlots, tabCrash, tabCoinflip, tabMinefield, tabMemory, tabHorserace, tabRoulette, tabBlackjack]; // Added Blackjack
        const allGameAreas = [gameSlots, gameCrash, gameCoinflip, gameMinefield, gameMemory, gameHorserace, gameRoulette, gameBlackjack]; // Added Blackjack
        // Slots
        const reelElements = [document.getElementById('reel1'), document.getElementById('reel2'), document.getElementById('reel3')];
        const reelContainers = Array.from(reelElements).map(el => el.closest('.reel'));
        const spinButton = document.getElementById('spin-button');
        const autoSpinToggle = document.getElementById('auto-spin-toggle');
        const slotBetInput = document.getElementById('slot-bet');
        const slotBetDecrease10Btn = document.getElementById('slot-bet-decrease-10');
        const slotBetDecrease1Btn = document.getElementById('slot-bet-decrease-1');
        const slotBetIncrease1Btn = document.getElementById('slot-bet-increase-1');
        const slotBetIncrease10Btn = document.getElementById('slot-bet-increase-10');
        const slotBetMinBtn = document.getElementById('slot-bet-min');
        const slotBetHalfBtn = document.getElementById('slot-bet-half');
        const slotBetDoubleBtn = document.getElementById('slot-bet-double');
        const slotBetMaxBtn = document.getElementById('slot-bet-max');
        const payoutList = document.getElementById('payout-list');
        // Crash
        const crashGraph = document.getElementById('crash-graph');
        const crashMultiplierDisplay = document.getElementById('crash-multiplier');
        const crashSvg = document.getElementById('crash-svg');
        const crashGrid = document.getElementById('crash-grid');
        const crashPolyline = document.getElementById('crash-polyline');
        const crashBetInput = document.getElementById('crash-bet');
        const crashBetButton = document.getElementById('crash-bet-button');
        const crashCashoutButton = document.getElementById('crash-cashout-button');
        const crashStatus = document.getElementById('crash-status');
        const crashBetDecrease10Btn = document.getElementById('crash-bet-decrease-10');
        const crashBetDecrease1Btn = document.getElementById('crash-bet-decrease-1');
        const crashBetIncrease1Btn = document.getElementById('crash-bet-increase-1');
        const crashBetIncrease10Btn = document.getElementById('crash-bet-increase-10');
        const crashBetMinBtn = document.getElementById('crash-bet-min');
        const crashBetHalfBtn = document.getElementById('crash-bet-half');
        const crashBetDoubleBtn = document.getElementById('crash-bet-double');
        const crashBetMaxBtn = document.getElementById('crash-bet-max');
        const crashAutoBetToggle = document.getElementById('crash-auto-bet-toggle');
        const crashAutoCashoutInput = document.getElementById('crash-auto-cashout-input');
        const crashAutoCashoutToggle = document.getElementById('crash-auto-cashout-toggle');
        // Coin Flip
        const coinElement = document.getElementById('coin');
        const coinflipBetInput = document.getElementById('coinflip-bet');
        const coinflipButton = document.getElementById('coinflip-button');
        const coinflipCashoutButton = document.getElementById('coinflip-cashout-button');
        const coinflipWinningsSpan = document.getElementById('coinflip-winnings');
        const coinflipStatus = document.getElementById('coinflip-status');
        const coinflipBetDecrease10Btn = document.getElementById('coinflip-bet-decrease-10');
        const coinflipBetDecrease1Btn = document.getElementById('coinflip-bet-decrease-1');
        const coinflipBetIncrease1Btn = document.getElementById('coinflip-bet-increase-1');
        const coinflipBetIncrease10Btn = document.getElementById('coinflip-bet-increase-10');
        const coinflipBetMinBtn = document.getElementById('coinflip-bet-min');
        const coinflipBetHalfBtn = document.getElementById('coinflip-bet-half');
        const coinflipBetDoubleBtn = document.getElementById('coinflip-bet-double');
        const coinflipBetMaxBtn = document.getElementById('coinflip-bet-max');
        const coinflipChooseBlueBtn = document.getElementById('coinflip-choose-blue');
        const coinflipChooseYellowBtn = document.getElementById('coinflip-choose-yellow');
        // Minefield
        const minefieldBetInput = document.getElementById('minefield-bet');
        const minefieldGridElement = document.getElementById('minefield-grid');
        const minefieldStartButton = document.getElementById('minefield-start-button');
        const minefieldCashoutButton = document.getElementById('minefield-cashout-button');
        const minefieldMultiplierSpan = document.getElementById('minefield-current-multiplier');
        const minefieldStatus = document.getElementById('minefield-status');
        const minefieldBetDecrease10Btn = document.getElementById('minefield-bet-decrease-10');
        const minefieldBetDecrease1Btn = document.getElementById('minefield-bet-decrease-1');
        const minefieldBetIncrease1Btn = document.getElementById('minefield-bet-increase-1');
        const minefieldBetIncrease10Btn = document.getElementById('minefield-bet-increase-10');
        const minefieldBetMinBtn = document.getElementById('minefield-bet-min');
        const minefieldBetHalfBtn = document.getElementById('minefield-bet-half');
        const minefieldBetDoubleBtn = document.getElementById('minefield-bet-double');
        const minefieldBetMaxBtn = document.getElementById('minefield-bet-max');
        // Memory Game
        const memoryBetInput = document.getElementById('memory-bet');
        const memoryGridElement = document.getElementById('memory-grid');
        const memoryStartButton = document.getElementById('memory-start-button');
        const memoryTriesLeftSpan = document.getElementById('memory-tries-left');
        const memoryStatus = document.getElementById('memory-status');
        const memoryBetDecrease10Btn = document.getElementById('memory-bet-decrease-10');
        const memoryBetDecrease1Btn = document.getElementById('memory-bet-decrease-1');
        const memoryBetIncrease1Btn = document.getElementById('memory-bet-increase-1');
        const memoryBetIncrease10Btn = document.getElementById('memory-bet-increase-10');
        const memoryBetMinBtn = document.getElementById('memory-bet-min');
        const memoryBetHalfBtn = document.getElementById('memory-bet-half');
        const memoryBetDoubleBtn = document.getElementById('memory-bet-double');
        const memoryBetMaxBtn = document.getElementById('memory-bet-max');
        // Horse Race
        const horseraceBetInput = document.getElementById('horserace-bet');
        const horseraceSelectionContainer = document.getElementById('horserace-selection');
        const horseraceTrack = document.getElementById('horserace-track');
        let horseElements = []; // Will be populated in createHorses
        const horseraceStartButton = document.getElementById('horserace-start-button');
        const horseraceStatus = document.getElementById('horserace-status');
        const horseraceBetDecrease10Btn = document.getElementById('horserace-bet-decrease-10');
        const horseraceBetDecrease1Btn = document.getElementById('horserace-bet-decrease-1');
        const horseraceBetIncrease1Btn = document.getElementById('horserace-bet-increase-1');
        const horseraceBetIncrease10Btn = document.getElementById('horserace-bet-increase-10');
        const horseraceBetMinBtn = document.getElementById('horserace-bet-min');
        const horseraceBetHalfBtn = document.getElementById('horserace-bet-half');
        const horseraceBetDoubleBtn = document.getElementById('horserace-bet-double');
        const horseraceBetMaxBtn = document.getElementById('horserace-bet-max');
        // Roulette
        const rouletteBetInput = document.getElementById('roulette-bet');
        const rouletteWheel = document.getElementById('roulette-wheel');
        const rouletteResultDisplay = document.getElementById('roulette-result');
        const rouletteInsideBetsContainer = document.getElementById('roulette-inside-bets');
        const rouletteOutsideBetsContainer = document.getElementById('roulette-outside-bets');
        const rouletteSpinButton = document.getElementById('roulette-spin-button');
        const rouletteStatus = document.getElementById('roulette-status');
        const rouletteCurrentBetSpan = document.getElementById('roulette-current-bet-type');
        const rouletteBetDecrease10Btn = document.getElementById('roulette-bet-decrease-10');
        const rouletteBetDecrease1Btn = document.getElementById('roulette-bet-decrease-1');
        const rouletteBetIncrease1Btn = document.getElementById('roulette-bet-increase-1');
        const rouletteBetIncrease10Btn = document.getElementById('roulette-bet-increase-10');
        const rouletteBetMinBtn = document.getElementById('roulette-bet-min');
        const rouletteBetHalfBtn = document.getElementById('roulette-bet-half');
        const rouletteBetDoubleBtn = document.getElementById('roulette-bet-double');
        const rouletteBetMaxBtn = document.getElementById('roulette-bet-max');
        // Blackjack
        const blackjackBetInput = document.getElementById('blackjack-bet');
        const blackjackDealButton = document.getElementById('blackjack-deal-button');
        const blackjackHitButton = document.getElementById('blackjack-hit-button');
        const blackjackStandButton = document.getElementById('blackjack-stand-button');
        const blackjackPlayerHandElement = document.getElementById('blackjack-player-hand');
        const blackjackDealerHandElement = document.getElementById('blackjack-dealer-hand');
        const blackjackPlayerScoreElement = document.getElementById('blackjack-player-score');
        const blackjackDealerScoreElement = document.getElementById('blackjack-dealer-score');
        const blackjackStatus = document.getElementById('blackjack-status');
        const blackjackBetDecrease10Btn = document.getElementById('blackjack-bet-decrease-10');
        const blackjackBetDecrease1Btn = document.getElementById('blackjack-bet-decrease-1');
        const blackjackBetIncrease1Btn = document.getElementById('blackjack-bet-increase-1');
        const blackjackBetIncrease10Btn = document.getElementById('blackjack-bet-increase-10');
        const blackjackBetMinBtn = document.getElementById('blackjack-bet-min');
        const blackjackBetHalfBtn = document.getElementById('blackjack-bet-half');
        const blackjackBetDoubleBtn = document.getElementById('blackjack-bet-double');
        const blackjackBetMaxBtn = document.getElementById('blackjack-bet-max');
        // ATM Modal
        const atmModalOverlay = document.getElementById('atm-modal-overlay');
        const atmModal = document.getElementById('atm-modal');
        const atmCloseButton = document.getElementById('atm-close-button');
        const atmButtons = atmModal.querySelectorAll('.atm-button');
        // Stats
        const statsTotalGain = document.getElementById('stats-total-gain');
        const statsTotalLoss = document.getElementById('stats-total-loss');
        const statsNetProfit = document.getElementById('stats-net-profit');

        // --- Core Functions ---

        // Update the state of the 'Pay Loan' button based on balance and loan amount
        function updatePayLoanButtonState() {
            const canPay = currency >= totalLoanAmount && totalLoanAmount > 0;
            payLoanButton.disabled = !canPay;
        }

        // Simple pulse animation for highlighting elements
        function flashElement(element) {
            if (!element) return;
            element.classList.add('animate-pulse');
            setTimeout(() => {
                element.classList.remove('animate-pulse');
            }, 600); // Duration of pulse animation
        }

        // Update the session statistics display
        function updateStatsDisplay() {
            const oldGain = parseFloat(statsTotalGain.textContent.replace(/,/g, '')) || 0;
            const oldLoss = parseFloat(statsTotalLoss.textContent.replace(/,/g, '')) || 0;
            const oldNet = parseFloat(statsNetProfit.textContent.replace(/,/g, '')) || 0;

            statsTotalGain.textContent = totalGain.toLocaleString();
            statsTotalLoss.textContent = totalLoss.toLocaleString();
            const net = totalGain - totalLoss;
            statsNetProfit.textContent = net.toLocaleString();

            // Apply color based on net profit/loss
            statsNetProfit.className = 'stats-value'; // Reset classes first
            if (net > 0) {
                statsNetProfit.classList.add('text-profit');
            } else if (net < 0) {
                statsNetProfit.classList.add('text-loss');
            }

            // Flash if values changed
            if (totalGain !== oldGain) flashElement(statsTotalGain);
            if (totalLoss !== oldLoss) flashElement(statsTotalLoss);
            if (net !== oldNet) flashElement(statsNetProfit);
        }

        // Flash the currency display green for win, red for loss
        function flashCurrency(type) {
            currencyDisplay.classList.remove('flash-win', 'flash-loss');
            void currencyDisplay.offsetWidth; // Trigger reflow to restart animation
            if (type === 'win') {
                currencyDisplay.classList.add('flash-win');
            } else if (type === 'loss') {
                currencyDisplay.classList.add('flash-loss');
            }
            // Remove class after animation duration
            setTimeout(() => {
                currencyDisplay.classList.remove('flash-win', 'flash-loss');
            }, 600);
        }

        // Update currency and loan displays, and related button states
        function updateCurrencyDisplay(changeType = null) { // changeType: 'win' or 'loss' or null
            currencyDisplay.textContent = currency.toLocaleString();
            loanBalanceDisplay.textContent = totalLoanAmount.toLocaleString();
            updatePayLoanButtonState();
            updateStatsDisplay(); // Update stats whenever currency changes
            if (changeType) {
                flashCurrency(changeType);
            }
        }

        // Show a temporary message at the bottom of the screen
        function showMessage(text, duration = 3000) {
            messageBox.textContent = text;
            messageBox.classList.add('show');
            // Hide the message after the duration
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, duration);
        }

        // Format win amounts for display
        function formatWin(amount) {
            return amount.toLocaleString();
        }

        // Add a win to the leaderboard
        function addWinToLeaderboard(type, winAmount) {
            if (winAmount <= 0) return; // Only add actual wins
            leaderboard.push({ type: type, win: winAmount });
            // Sort leaderboard descending by win amount
            leaderboard.sort((a, b) => b.win - a.win);
            // Keep only the top entries
            leaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            saveGameState(); // Save after updating leaderboard
            updateLeaderboardDisplay(); // Update the UI
        }

        // Update the leaderboard UI
        function updateLeaderboardDisplay() {
            const oldList = Array.from(leaderboardList.children).map(li => li.textContent); // Get text of old entries
            leaderboardList.innerHTML = ''; // Clear the list
            if (leaderboard.length === 0) {
                leaderboardList.innerHTML = '<li class="text-gray-500">No wins yet! Play a game!</li>';
                return;
            }
            leaderboard.forEach((entry, index) => {
                const li = document.createElement('li');
                const entryText = `${entry.type}: ${formatWin(entry.win)}`; // Consistent format
                li.className = 'flex justify-between items-center text-sm';
                // Check if this entry is new compared to the old list content
                if (!oldList.some(oldText => oldText.includes(entryText))) {
                    li.classList.add('leaderboard-entry-new'); // Add animation class for new entries
                    li.style.animationDelay = `${index * 0.05}s`; // Stagger animation
                }
                li.innerHTML = `
                    <span class="font-medium text-gray-300">${entry.type}</span>
                    <span class="text-green-400 font-semibold">${formatWin(entry.win)}</span>
                `;
                leaderboardList.appendChild(li);
            });
        }

        // Save game state to localStorage
        function saveGameState() {
            try {
                localStorage.setItem('brokieCasinoState', JSON.stringify({
                    currency: currency,
                    leaderboard: leaderboard,
                    totalLoanAmount: totalLoanAmount,
                    totalGain: totalGain,
                    totalLoss: totalLoss,
                    // Add other game-specific states if persistence is needed (e.g., auto-bet settings)
                }));
            } catch (e) {
                console.error("Error saving game state:", e);
                showMessage("Could not save game progress.", 2000);
            }
        }

        // Load game state from localStorage
        function loadGameState() {
            const savedState = localStorage.getItem('brokieCasinoState');
            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    // Validate loaded data or use defaults
                    currency = state.currency !== undefined && !isNaN(state.currency) ? state.currency : 500;
                    leaderboard = Array.isArray(state.leaderboard) ? state.leaderboard : [];
                    totalLoanAmount = state.totalLoanAmount !== undefined && !isNaN(state.totalLoanAmount) ? state.totalLoanAmount : 0;
                    totalGain = state.totalGain !== undefined && !isNaN(state.totalGain) ? state.totalGain : 0;
                    totalLoss = state.totalLoss !== undefined && !isNaN(state.totalLoss) ? state.totalLoss : 0;
                    // Load other saved states here if added
                } catch (e) {
                    console.error("Error loading saved state:", e);
                    // Reset to defaults if loading fails
                    currency = 500;
                    leaderboard = [];
                    totalLoanAmount = 0;
                    totalGain = 0;
                    totalLoss = 0;
                    localStorage.removeItem('brokieCasinoState'); // Clear corrupted state
                }
            }
            // Ensure leaderboard doesn't exceed max entries after loading
            leaderboard = leaderboard.slice(0, MAX_LEADERBOARD_ENTRIES);
            updateCurrencyDisplay(); // Update UI with loaded values
            updateLeaderboardDisplay();
        }

        // Display the slot machine payout legend
        function displayPayoutLegend() {
            payoutList.innerHTML = ''; // Clear existing list
            // Sort payouts by value descending for better readability
            const sortedPayouts = Object.entries(slotPayouts).sort(([,a],[,b]) => b-a);
            for (const [key, value] of sortedPayouts) {
                const li = document.createElement('li');
                li.innerHTML = `<span>${key}</span><span>${value}x</span>`;
                payoutList.appendChild(li);
            }
        }

        // Switch between game tabs
        function setActiveTab(selectedTab) {
            // Stop any active auto-play or ongoing games when switching tabs
            if (isAutoSpinning && selectedTab !== tabSlots) { stopAutoSpin(); }
            if (isCrashAutoBetting && selectedTab !== tabCrash) { stopCrashAutoBet(); } // Stop auto bet if switching from Crash
            if (crashGameActive && selectedTab !== tabCrash) { endCrashGame(true, 0, true); } // Force end crash game if active
            if (coinFlipActive && selectedTab !== tabCoinflip) { resetCoinFlip(); }
            if (minefieldActive && selectedTab !== tabMinefield) { resetMinefield(); }
            if (memoryActive && selectedTab !== tabMemory) { resetMemoryGame(); }
            if (horseraceActive && selectedTab !== tabHorserace) { resetHorserace(); }
            if (rouletteIsSpinning && selectedTab !== tabRoulette) { resetRoulette(); }
            if (blackjackActive && selectedTab !== tabBlackjack) { resetBlackjack(false); } // Reset blackjack if active (don't refund bet)

            // Handle tab switching visuals and game area visibility
            allTabs.forEach(tab => {
                const gameAreaId = tab.id.replace('tab-', 'game-');
                const gameArea = document.getElementById(gameAreaId);
                if (tab === selectedTab) {
                    tab.setAttribute('aria-current', 'page'); // Highlight active tab
                    if (gameArea) {
                        gameArea.classList.remove('hidden', 'opacity-0');
                        gameArea.classList.add('opacity-100'); // Make game area visible

                        // Specific initializations when switching TO a tab
                        if (tab === tabCrash) {
                            updateCrashAutoCashoutToggleVisuals(); // Ensure crash input state is correct
                        }
                        if (tab === tabHorserace && horseElements.length === 0) {
                            createHorses(); // Create horse elements if not already done
                            resetHorserace(); // Reset positions and UI state
                        }
                        if (tab === tabRoulette && !rouletteInsideBetsContainer.hasChildNodes()) {
                            createRouletteBettingGrid(); // Create roulette grid if not done
                            resetRoulette(); // Reset roulette state
                        }
                        if (tab === tabBlackjack) {
                            resetBlackjack(false); // Ensure clean state when switching to Blackjack
                        }
                    }
                } else {
                    tab.removeAttribute('aria-current'); // Unhighlight inactive tabs
                    if (gameArea) {
                        // Start fade out
                        gameArea.classList.add('opacity-0');
                        // Hide after transition (300ms matches CSS transition)
                        setTimeout(() => {
                            // Only hide if the tab is still not the selected one (prevents flicker if quickly switching back)
                            if (!tab.hasAttribute('aria-current')) {
                                gameArea.classList.add('hidden');
                            }
                        }, 300);
                    }
                }
            });
        }

        // Adjust bet amount based on operation
        function adjustBet(inputElement, amount, operation) {
            let currentBet = parseInt(inputElement.value);
            if (isNaN(currentBet)) currentBet = 1; // Default to 1 if input is invalid

            let newBet = currentBet;
            const minBet = 1;
            // Max bet is generally the current currency, but ensure it's at least minBet
            const maxBet = Math.max(minBet, currency);

            switch (operation) {
                case 'add': newBet = currentBet + amount; break;
                case 'subtract': newBet = currentBet - amount; break;
                case 'multiply': newBet = Math.floor(currentBet * amount); break;
                case 'divide': newBet = Math.floor(currentBet / amount); break;
                case 'min': newBet = minBet; break;
                case 'max': newBet = maxBet; break;
                case 'set': newBet = amount; break; // Directly set the value (e.g., from input change)
            }

            // Clamp the new bet between min and max
            newBet = Math.max(minBet, newBet);
            // Don't allow setting bet higher than max, unless it's the 'min' operation
            if (operation !== 'min') {
                newBet = Math.min(maxBet, newBet);
            }
            // If max bet is less than min bet (e.g., currency is 0), force to min bet
            if (maxBet < minBet) {
                newBet = minBet;
            }

            inputElement.value = newBet; // Update the input field
            playSound('click'); // Play click sound for bet adjustment
        }

        // --- Slot Machine Logic ---
        function getRandomSymbol() { return slotSymbols[Math.floor(Math.random() * slotSymbols.length)]; }

        function spinReels() {
            if (spinButton.disabled) return; // Prevent multiple spins

            const betAmount = parseInt(slotBetInput.value);
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", 2000);
                stopAutoSpin(); return;
            }
            if (betAmount > currency) {
                showMessage("Not enough currency! Try the loan button?", 2000);
                stopAutoSpin(); return;
            }

            startTone(); // Ensure audio context is ready
            playSound('spin_start');
            currency -= betAmount;
            updateCurrencyDisplay('loss');
            spinButton.disabled = true;
            spinButton.textContent = 'Spinning...';
            reelContainers.forEach(c => c.classList.remove('win-effect')); // Clear previous win effects

            let finalSymbols = [];
            let activeReels = reelElements.length;

            reelElements.forEach((reelSymbolElement, index) => {
                const reelContainer = reelSymbolElement.parentElement;
                if (!reelContainer) {
                    console.error(`Could not find container for reel ${index + 1}`);
                    activeReels--;
                    if (activeReels === 0) finalizeSpin(finalSymbols, betAmount); // Finalize if this was the last reel
                    return;
                }

                // Prepare the visual spin effect
                reelSymbolElement.style.transition = 'none'; // Disable transition for instant reset
                reelSymbolElement.style.top = `-${REEL_SPIN_OFFSET}px`; // Move instantly to top offset

                // Generate the strip of symbols for visual effect + final symbol
                let symbolStripHTML = '';
                const stripLength = 20; // Number of symbols in the visual strip
                for (let i = 0; i < stripLength; i++) {
                    symbolStripHTML += `<div style="height: 100px; line-height: 100px;">${getRandomSymbol()}</div>`;
                }
                const finalSymbol = getRandomSymbol();
                finalSymbols[index] = finalSymbol; // Store the actual result
                symbolStripHTML += `<div style="height: 100px; line-height: 100px;">${finalSymbol}</div>`; // Add final symbol at the end
                reelSymbolElement.innerHTML = symbolStripHTML;

                // Force reflow to apply the reset position before starting animation
                reelContainer.offsetHeight;

                // Define transition end handler for this specific reel
                const transitionEndHandler = () => {
                    reelSymbolElement.removeEventListener('transitionend', transitionEndHandler); // Clean up listener
                    playSound('reel_stop', { index: index }); // Pass index to sound
                    activeReels--;
                    if (activeReels === 0) {
                        finalizeSpin(finalSymbols, betAmount); // Call finalize only when ALL reels stopped
                    }
                };
                reelSymbolElement.addEventListener('transitionend', transitionEndHandler);

                // Start the animation using requestAnimationFrame for smoother start
                requestAnimationFrame(() => {
                    reelSymbolElement.style.transition = `top ${SPIN_DURATION / 1000 + index * 0.1}s cubic-bezier(0.25, 1, 0.5, 1)`; // Staggered duration
                    const finalTopPosition = -(reelSymbolElement.scrollHeight - reelContainer.clientHeight); // Calculate final position
                    reelSymbolElement.style.top = `${finalTopPosition}px`;
                });

                // Fallback timeout in case transitionend doesn't fire (rare, but possible)
                setTimeout(() => {
                    if (activeReels > 0 && reelSymbolElement.style.transition !== 'none') { // Check if still active
                        console.warn(`Transition fallback for reel ${index + 1}`);
                        reelSymbolElement.removeEventListener('transitionend', transitionEndHandler); // Clean up listener
                        playSound('reel_stop', { index: index }); // Pass index to sound
                        activeReels--;
                        if (activeReels === 0) {
                            finalizeSpin(finalSymbols, betAmount);
                        }
                    }
                }, SPIN_DURATION + 300 + index * 100); // Generous fallback timer
            });
        }

        function finalizeSpin(finalSymbols, betAmount) {
            let spinError = false;
            try {
                if (finalSymbols.length === reelElements.length) {
                    checkSlotWin(finalSymbols, betAmount); // Check for wins
                } else {
                    console.error("Final symbols array length mismatch before check:", finalSymbols);
                    showMessage("Error processing spin results.", 2000);
                    spinError = true;
                }
            } catch (e) {
                console.error("Error during win check:", e);
                showMessage("An error occurred checking the win.", 2000);
                spinError = true;
            } finally {
                // Reset UI regardless of win/error
                spinButton.disabled = false;
                spinButton.textContent = 'Spin';

                // Ensure final symbols are displayed correctly
                reelElements.forEach((reelSymbolElement, index) => {
                    if (finalSymbols[index]) {
                        reelSymbolElement.style.transition = 'none'; // Remove transition
                        reelSymbolElement.innerHTML = `<div style="height: 100px; line-height: 100px;">${finalSymbols[index]}</div>`; // Display final symbol
                        reelSymbolElement.style.top = '0px'; // Reset position
                    } else { // Fallback if a symbol was missing
                        reelSymbolElement.innerHTML = `<div style="height: 100px; line-height: 100px;">❓</div>`;
                        reelSymbolElement.style.top = '0px';
                    }
                });

                // Handle auto-spin continuation
                if (isAutoSpinning) {
                    clearTimeout(slotSpinTimeout); // Clear previous timeout if any
                    if (spinError || currency < parseInt(slotBetInput.value) || parseInt(slotBetInput.value) <= 0) {
                        stopAutoSpin(); // Stop auto-spin on error or insufficient funds
                    } else {
                        slotSpinTimeout = setTimeout(spinReels, 500); // Schedule next spin after a short delay
                    }
                }
            }
        }

        function checkSlotWin(symbols, betAmount) {
            const [s1, s2, s3] = symbols;
            let winAmount = 0;
            let winKey = '';
            let winSound = null;
            let winningReels = [];

            // Check for 3-symbol matches first (highest payout)
            if (s1 === s2 && s2 === s3) {
                winKey = `${s1}${s2}${s3}`;
                winningReels = [0, 1, 2];
            }
            // Check for 2-symbol matches (only if specific payouts exist)
            else if (slotPayouts[`${s1}${s2}`]) { // Check left-to-right pair
                winKey = `${s1}${s2}`;
                winningReels = [0, 1];
            } else if (slotPayouts[`${s2}${s3}`]) { // Check middle-right pair (less common rule)
                winKey = `${s2}${s3}`;
                winningReels = [1, 2];
            }
            // Add specific checks like 'any two cherries' if needed, e.g.:
            // else if ((s1 === '🍒' && s2 === '🍒') || (s2 === '🍒' && s3 === '🍒')) {
            //     winKey = '🍒🍒'; // Assuming '🍒🍒' exists in slotPayouts
            //     winningReels = (s1 === '🍒' && s2 === '🍒') ? [0, 1] : [1, 2];
            // }

            // Calculate winnings if a winning combination was found
            if (slotPayouts[winKey]) {
                winAmount = betAmount * slotPayouts[winKey];
                currency += winAmount;
                totalGain += winAmount; // Add full win amount to gain
                addWinToLeaderboard('Slots', winAmount); // Add win to leaderboard

                // Determine sound based on multiplier size
                const multiplier = slotPayouts[winKey];
                if (multiplier >= 100) winSound = 'win_big';
                else if (multiplier >= 25) winSound = 'win_medium';
                else winSound = 'win_small';

                showMessage(`WIN! ${formatWin(winAmount)}! (${winKey})`, 3000);
                winningReels.forEach(i => reelContainers[i]?.classList.add('win-effect')); // Highlight winning reels
                setTimeout(() => winningReels.forEach(i => reelContainers[i]?.classList.remove('win-effect')), 1000); // Remove highlight after delay
            } else {
                // No win, bet amount is already subtracted, just add to total loss
                totalLoss += betAmount;
                showMessage("No win this time. Spin again!", 2000);
                winSound = 'lose'; // Play lose sound
            }

            if (winSound) playSound(winSound, winAmount); // Play appropriate sound
            updateCurrencyDisplay(winAmount > 0 ? 'win' : null); // Update currency display (flash if win)
            saveGameState(); // Save state after win/loss calculation
        }

        function stopAutoSpin() {
            isAutoSpinning = false;
            clearTimeout(slotSpinTimeout); // Clear any scheduled spin
            autoSpinToggle.classList.remove('active');
            autoSpinToggle.textContent = 'Auto Off';
        }

        function toggleAutoSpin() {
            isAutoSpinning = !isAutoSpinning;
            if (isAutoSpinning) {
                autoSpinToggle.classList.add('active');
                autoSpinToggle.textContent = 'Auto ON';
                spinReels(); // Start the first auto-spin immediately
            } else {
                stopAutoSpin();
            }
        }


        // --- Crash Game Logic ---

        // Update the background grid lines in the SVG
        function updateCrashGrid(viewBox) {
            crashGrid.innerHTML = ''; // Clear existing grid lines
            const vb = viewBox;
            const numVerticalLines = 5;
            const numHorizontalLines = 4;

            // Draw vertical lines
            const xStep = vb.width / numVerticalLines;
            for (let i = 1; i <= numVerticalLines; i++) {
                const x = vb.x + i * xStep;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', x.toFixed(2));
                line.setAttribute('y1', vb.y.toFixed(2));
                line.setAttribute('x2', x.toFixed(2));
                line.setAttribute('y2', (vb.y + vb.height).toFixed(2));
                line.setAttribute('class', 'grid-line');
                crashGrid.appendChild(line);
            }

            // Draw horizontal lines
            const yStep = vb.height / numHorizontalLines;
            for (let i = 1; i < numHorizontalLines; i++) { // Start from 1, end before numHorizontalLines
                const y = vb.y + i * yStep;
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', vb.x.toFixed(2));
                line.setAttribute('y1', y.toFixed(2));
                line.setAttribute('x2', (vb.x + vb.width).toFixed(2));
                line.setAttribute('y2', y.toFixed(2));
                line.setAttribute('class', 'grid-line');
                crashGrid.appendChild(line);
            }
        }

        // Reset crash game visuals to the starting state
        function resetCrashVisuals() {
            crashMultiplier = 1.00;
            crashTimeStep = 0;
            // Reset SVG viewbox
            currentViewBox = { x: 0, y: 0, width: INITIAL_VIEWBOX_WIDTH, height: INITIAL_VIEWBOX_HEIGHT };
            crashSvg.setAttribute('viewBox', `0 0 ${INITIAL_VIEWBOX_WIDTH} ${INITIAL_VIEWBOX_HEIGHT}`);
            // Reset multiplier display
            crashMultiplierDisplay.textContent = `${crashMultiplier.toFixed(2)}x`;
            crashMultiplierDisplay.className = ''; // Clear all classes first
            crashMultiplierDisplay.classList.add('text-gray-300'); // Re-add default class
            crashMultiplierDisplay.style.fontSize = ''; // Reset font size
            // Reset graph line
            crashPolyline.setAttribute('points', `0,${INITIAL_VIEWBOX_HEIGHT}`); // Start at bottom-left
            crashPolyline.style.stroke = '#34d399'; // Reset to green
            crashStatus.textContent = ''; // Clear status message
            updateCrashGrid(currentViewBox); // Redraw initial grid
        }

        // Calculate the target multiplier where the game will crash
        function calculateCrashTarget() {
            const r = Math.random();
            const houseEdge = 0.03; // 3% house edge for instant crash

            // Instant crash based on house edge
            if (r < houseEdge) {
                return 1.00;
            }

            // Calculate multiplier using an exponential distribution adjusted for house edge
            // This formula creates more lower multipliers and fewer very high ones
            const effectiveRandom = (r - houseEdge) / (1 - houseEdge); // Adjust random number to exclude house edge range
            const exponent = 2.5; // Controls the curve steepness (higher = more low multipliers)
            const multiplierBase = 1 / Math.pow(1 - effectiveRandom, 1 / exponent);

            // Ensure minimum multiplier is 1.01 and round to 2 decimal places
            return Math.max(1.01, Math.floor(multiplierBase * 100) / 100);
        }

        // Start a new round of the crash game
        function startCrashGame() {
            // Check bet validity, especially for auto-bet
            if (isCrashAutoBetting) {
                const betAmount = parseInt(crashBetInput.value);
                if (isNaN(betAmount) || betAmount <= 0 || betAmount > currency) {
                    showMessage("Auto-bet stopped: Invalid bet or insufficient funds.", 3000);
                    stopCrashAutoBet();
                    return;
                }
            } else { // Manual bet validation
                const betAmount = parseInt(crashBetInput.value);
                if (isNaN(betAmount) || betAmount <= 0) {
                    showMessage("Please enter a valid positive bet amount.", 2000); return;
                }
                if (betAmount > currency) {
                    showMessage("Not enough currency! Try the loan button?", 2000); return;
                }
            }

            if (crashGameActive) return; // Don't start if already active

            const betAmount = parseInt(crashBetInput.value);
            startTone(); // Ensure audio context
            crashPlayerBet = betAmount;
            currency -= betAmount;
            updateCurrencyDisplay('loss'); // Update display immediately

            crashGameActive = true;
            crashCashedOut = false;
            crashTargetMultiplier = calculateCrashTarget();
            resetCrashVisuals(); // Reset graph and multiplier display
            crashStatus.innerHTML = `Bet Placed! Current Value: <span id="potential-win-amount" class="font-bold text-gray-300">${formatWin(crashPlayerBet)}</span>`;

            // Disable controls during game
            crashBetButton.disabled = true;
            crashCashoutButton.disabled = false; // Enable cashout
            crashBetInput.disabled = true;
            crashAutoBetToggle.disabled = true;
            crashAutoCashoutToggle.disabled = true;
            crashAutoCashoutInput.disabled = true; // Disable input during game

            crashMultiplierDisplay.classList.remove('win-effect'); // Remove previous win effect
            crashGraph.offsetHeight; // Force reflow for smooth animation start

            let pathPoints = [[0, INITIAL_VIEWBOX_HEIGHT]]; // Start path at bottom-left

            // --- Crash Game Loop ---
            crashInterval = setInterval(() => {
                if (!crashGameActive) { // Stop loop if game ended externally
                    clearInterval(crashInterval);
                    return;
                }

                crashTimeStep++;

                // Calculate multiplier increment (increases faster at higher multipliers)
                const randomFactor = 0.7 + Math.random() * 0.6; // Add some randomness
                const baseIncrement = 0.01 * Math.max(1, Math.pow(crashMultiplier, 0.4));
                const increment = baseIncrement * randomFactor;
                crashMultiplier += increment;

                // Check for Auto Cashout
                if (isAutoCashoutEnabled && !crashCashedOut && crashMultiplier >= autoCashoutTarget) {
                    showMessage(`Auto-cashed out at ${autoCashoutTarget.toFixed(2)}x!`, 2000);
                    attemptCashOut(); // Attempt cashout automatically
                    return; // Exit loop after auto-cashout attempt
                }

                // Check for Crash
                if (crashMultiplier >= crashTargetMultiplier) {
                    clearInterval(crashInterval); // Stop the game loop
                    crashInterval = null;
                    crashMultiplier = crashTargetMultiplier; // Set final multiplier to target
                    crashMultiplierDisplay.textContent = `${crashMultiplier.toFixed(2)}x`; // Display final multiplier

                    // Calculate final point and update SVG viewbox to ensure line is visible
                    const finalX = crashTimeStep * (INITIAL_VIEWBOX_WIDTH / 100);
                    const finalY = INITIAL_VIEWBOX_HEIGHT - Math.max(0, (crashMultiplier - 1) * CRASH_Y_SCALING_FACTOR);
                    pathPoints.push([finalX, finalY]);

                    // Adjust viewbox to fit the final point
                    let finalViewBoxWidth = Math.max(INITIAL_VIEWBOX_WIDTH, finalX * 1.1);
                    let finalViewBoxHeight = Math.max(INITIAL_VIEWBOX_HEIGHT, (INITIAL_VIEWBOX_HEIGHT - finalY) * 1.1);
                    let finalViewBoxX = Math.max(0, finalX - finalViewBoxWidth * VIEWBOX_PAN_THRESHOLD);
                    let finalViewBoxY = Math.max(0, INITIAL_VIEWBOX_HEIGHT - finalViewBoxHeight); // Ensure Y is not negative
                    currentViewBox = { x: finalViewBoxX, y: finalViewBoxY, width: finalViewBoxWidth, height: finalViewBoxHeight };
                    crashSvg.setAttribute('viewBox', `${currentViewBox.x.toFixed(2)} ${currentViewBox.y.toFixed(2)} ${currentViewBox.width.toFixed(2)} ${currentViewBox.height.toFixed(2)}`);
                    crashPolyline.setAttribute('points', pathPoints.map(p => `${p[0].toFixed(2)},${p[1].toFixed(2)}`).join(' '));
                    crashPolyline.style.stroke = '#ef4444'; // Turn line red on crash
                    updateCrashGrid(currentViewBox); // Update grid for final viewbox

                    // End the game after a short delay to show the crash point
                    setTimeout(() => endCrashGame(true, crashPlayerBet), 100); // Crashed = true
                    return; // Exit loop
                }

                // --- Update display during active game ---
                crashMultiplierDisplay.textContent = `${crashMultiplier.toFixed(2)}x`;
                const currentCashoutValue = Math.floor(crashPlayerBet * crashMultiplier);
                const potentialWinSpan = document.getElementById('potential-win-amount');
                if (potentialWinSpan) {
                    potentialWinSpan.textContent = formatWin(currentCashoutValue);
                } else { // Fallback if span somehow disappears
                    crashStatus.innerHTML = `Current Value: <span id="potential-win-amount" class="font-bold text-gray-300">${formatWin(currentCashoutValue)}</span>`;
                }

                // Apply visual effects based on multiplier
                const displaySpan = document.getElementById('potential-win-amount'); // Get span again for styling
                // Clear previous multiplier styles first
                crashMultiplierDisplay.classList.remove('shake-subtle', 'shake-strong', 'mult-color-5x', 'mult-color-10x', 'mult-color-15x', 'mult-color-20x', 'mult-color-30x', 'mult-size-10x', 'mult-size-20x', 'mult-size-30x');
                crashMultiplierDisplay.style.fontSize = ''; // Reset font size
                if (displaySpan) displaySpan.className = 'font-bold text-gray-300'; // Reset potential win color

                // Apply new styles based on current multiplier
                if (crashMultiplier >= 30) { crashMultiplierDisplay.classList.add('shake-strong', 'mult-color-30x', 'mult-size-30x'); if (displaySpan) displaySpan.classList.add('mult-color-30x'); }
                else if (crashMultiplier >= 20) { crashMultiplierDisplay.classList.add('shake-strong', 'mult-color-20x', 'mult-size-20x'); if (displaySpan) displaySpan.classList.add('mult-color-20x'); }
                else if (crashMultiplier >= 15) { crashMultiplierDisplay.classList.add('shake-strong', 'mult-color-15x', 'mult-size-10x'); if (displaySpan) displaySpan.classList.add('mult-color-15x'); }
                else if (crashMultiplier >= 10) { crashMultiplierDisplay.classList.add('shake-strong', 'mult-color-10x', 'mult-size-10x'); if (displaySpan) displaySpan.classList.add('mult-color-10x'); }
                else if (crashMultiplier >= 5) { crashMultiplierDisplay.classList.add('shake-subtle', 'mult-color-5x'); if (displaySpan) displaySpan.classList.add('mult-color-5x'); }
                else if (crashMultiplier >= 3) { crashMultiplierDisplay.classList.add('shake-subtle'); }

                // Update graph line and viewbox dynamically
                const currentX = crashTimeStep * (INITIAL_VIEWBOX_WIDTH / 100); // X position based on time step
                const currentY = INITIAL_VIEWBOX_HEIGHT - Math.max(0, (crashMultiplier - 1) * CRASH_Y_SCALING_FACTOR); // Y position based on multiplier
                pathPoints.push([currentX, currentY]);

                // Calculate required viewbox size to fit the current point
                let targetViewBoxWidth = currentViewBox.width;
                let targetViewBoxHeight = currentViewBox.height;
                let targetViewBoxX = currentViewBox.x;
                let targetViewBoxY = currentViewBox.y;

                const requiredWidth = Math.max(INITIAL_VIEWBOX_WIDTH, currentX * 1.1); // Need width at least initial, or 110% of current X
                const requiredHeight = Math.max(INITIAL_VIEWBOX_HEIGHT, (INITIAL_VIEWBOX_HEIGHT - currentY) * 1.1); // Need height at least initial, or 110% of current Y extent

                targetViewBoxWidth = Math.max(currentViewBox.width, requiredWidth); // Expand width if needed
                targetViewBoxHeight = Math.max(currentViewBox.height, requiredHeight); // Expand height if needed

                // Pan viewbox rightwards if point crosses threshold
                targetViewBoxX = Math.max(0, currentX - targetViewBoxWidth * VIEWBOX_PAN_THRESHOLD);
                // Pan viewbox upwards (decrease Y origin)
                targetViewBoxY = Math.max(0, INITIAL_VIEWBOX_HEIGHT - targetViewBoxHeight); // Y origin is top-left

                // Update viewbox state and SVG attribute
                currentViewBox = { x: targetViewBoxX, y: targetViewBoxY, width: targetViewBoxWidth, height: targetViewBoxHeight };
                crashSvg.setAttribute('viewBox', `${currentViewBox.x.toFixed(2)} ${currentViewBox.y.toFixed(2)} ${currentViewBox.width.toFixed(2)} ${currentViewBox.height.toFixed(2)}`);
                crashPolyline.setAttribute('points', pathPoints.map(p => `${p[0].toFixed(2)},${p[1].toFixed(2)}`).join(' ')); // Update polyline
                updateCrashGrid(currentViewBox); // Redraw grid for new viewbox

                // Change line color as it approaches crash target (visual tension)
                const closeness = crashMultiplier / crashTargetMultiplier;
                if (closeness > 0.8) {
                    const yellowIntensity = Math.min(255, 50 + (closeness - 0.8) * 1000);
                    const greenIntensity = Math.max(50, 200 - (closeness - 0.8) * 500);
                    crashPolyline.style.stroke = `rgb(${yellowIntensity}, ${greenIntensity}, 0)`;
                } else {
                    crashPolyline.style.stroke = '#34d399'; // Default green
                }
                // Play tick sound based on multiplier
                playSound('crash_tick', crashMultiplier);

            }, CRASH_UPDATE_INTERVAL);
        }

        // End the crash game round (either by crashing or cashing out)
        function endCrashGame(crashed, betAtEnd, stoppedByTabSwitch = false) {
            if (crashInterval) { // Ensure loop is stopped
                clearInterval(crashInterval);
                crashInterval = null;
            }
            if (!crashGameActive && !crashed && !stoppedByTabSwitch) { // Avoid ending already ended game unless forced by tab switch
                console.warn("endCrashGame called but game not active.");
                return;
            }

            // Make sure bet amount is correct for loss calculation if crashed
            const betForCalculation = crashed ? betAtEnd : crashPlayerBet;

            crashGameActive = false; // Mark game as inactive

            // Re-enable controls
            crashBetButton.disabled = false;
            crashCashoutButton.disabled = true; // Disable cashout after round ends
            crashBetInput.disabled = false;
            crashAutoBetToggle.disabled = false;
            crashAutoCashoutToggle.disabled = false;
            updateCrashAutoCashoutToggleVisuals(); // Update input state based on toggle

            // Handle crash outcome
            if (crashed && !stoppedByTabSwitch) {
                totalLoss += betForCalculation; // Add bet amount to total loss
                crashMultiplierDisplay.textContent = `CRASH! ${crashTargetMultiplier.toFixed(2)}x`;
                crashMultiplierDisplay.classList.remove('text-gray-300', 'win-effect');
                crashMultiplierDisplay.classList.add('text-red-500'); // Red text for crash
                crashPolyline.style.stroke = '#ef4444'; // Ensure line is red
                crashStatus.textContent = `Crashed! You lost ${formatWin(betForCalculation)}.`;
                playSound('crash_explode');
                updateCurrencyDisplay(); // Update currency (no change type)
            }
            // Handle cashout outcome
            else if (!crashed && !stoppedByTabSwitch) {
                const totalReturn = Math.floor(betForCalculation * crashMultiplier);
                const profit = totalReturn - betForCalculation;
                currency += totalReturn; // Add winnings back to currency
                totalGain += Math.max(0, profit); // Add profit to total gain

                if (profit > 0) {
                    crashStatus.textContent = `Cashed out @ ${crashMultiplier.toFixed(2)}x! Won ${formatWin(profit)}.`;
                    playSound('crash_cashout');
                    addWinToLeaderboard('Crash', profit);
                    crashMultiplierDisplay.classList.add('win-effect'); // Add win effect
                    setTimeout(() => crashMultiplierDisplay.classList.remove('win-effect'), 1000); // Remove effect after delay
                    updateCurrencyDisplay('win'); // Update currency (flash green)
                } else { // Cashed out at 1.00x or somehow less
                    crashStatus.textContent = `Cashed out @ ${crashMultiplier.toFixed(2)}x. No profit.`;
                    updateCurrencyDisplay(); // Update currency (no flash)
                }
            }
            // Handle game stopped by switching tabs
            else if (stoppedByTabSwitch) {
                // The bet was already subtracted, consider it a loss for simplicity unless cashed out before switch
                if (!crashCashedOut) {
                    totalLoss += betForCalculation;
                    crashStatus.textContent = "Game stopped by switching tabs. Bet lost.";
                    updateCurrencyDisplay();
                }
                // If cashed out just before switching, the win was already processed.
            }


            saveGameState(); // Save state after round ends
            crashPlayerBet = 0; // Reset player bet for the round

            // Start next round if auto-bet is on
            if (isCrashAutoBetting && !stoppedByTabSwitch) {
                setTimeout(startCrashGame, 1500); // Delay before starting next auto-bet round
            }
        }

        // Attempt to cash out the current crash game bet
        function attemptCashOut() {
            if (!crashGameActive || crashCashedOut) return; // Can't cash out if game not active or already cashed out
            crashCashedOut = true; // Mark as cashed out
            crashCashoutButton.disabled = true; // Disable button immediately
            // Pass false for 'crashed', use current crashPlayerBet
            endCrashGame(false, crashPlayerBet);
        }

        // Stop the crash auto-bet feature
        function stopCrashAutoBet() {
            isCrashAutoBetting = false;
            crashAutoBetToggle.classList.remove('active');
            crashAutoBetToggle.textContent = 'Auto Bet Off';
            // Re-enable controls if game is not currently active
            if (!crashGameActive) {
                crashBetButton.disabled = false;
                crashBetInput.disabled = false;
                crashAutoBetToggle.disabled = false;
                crashAutoCashoutToggle.disabled = false;
                updateCrashAutoCashoutToggleVisuals(); // Update input state
            }
        }

        // Toggle the crash auto-bet feature
        function toggleCrashAutoBet() {
            isCrashAutoBetting = !isCrashAutoBetting;
            if (isCrashAutoBetting) {
                crashAutoBetToggle.classList.add('active');
                crashAutoBetToggle.textContent = 'Auto Bet ON';
                if (!crashGameActive) {
                    startCrashGame(); // Start game immediately if auto-bet turned on and game inactive
                }
            } else {
                stopCrashAutoBet();
            }
        }

        // Update visuals and state of the auto-cashout input/toggle
        function updateCrashAutoCashoutToggleVisuals() {
            if (isAutoCashoutEnabled) {
                crashAutoCashoutToggle.classList.add('active');
                crashAutoCashoutToggle.textContent = 'Enabled';
                crashAutoCashoutInput.value = autoCashoutTarget > 0 ? autoCashoutTarget.toFixed(2) : '';
            } else {
                crashAutoCashoutToggle.classList.remove('active');
                crashAutoCashoutToggle.textContent = 'Enable';
            }
            // Input should be editable ONLY when the toggle is enabled AND the game is NOT active
            crashAutoCashoutInput.disabled = !(isAutoCashoutEnabled && !crashGameActive);
        }

        // Toggle the crash auto-cashout feature
        function toggleCrashAutoCashout() {
            isAutoCashoutEnabled = !isAutoCashoutEnabled;
            if (isAutoCashoutEnabled) {
                const target = parseFloat(crashAutoCashoutInput.value);
                if (isNaN(target) || target < 1.01) {
                    showMessage("Invalid auto-cashout target. Must be >= 1.01", 2500);
                    isAutoCashoutEnabled = false; // Turn back off if invalid
                } else {
                    autoCashoutTarget = target;
                    crashAutoCashoutInput.value = target.toFixed(2); // Format input
                    showMessage(`Auto-cashout enabled at ${target.toFixed(2)}x`, 2000);
                }
            } else {
                showMessage("Auto-cashout disabled.", 2000);
                autoCashoutTarget = 0; // Reset target
            }
            updateCrashAutoCashoutToggleVisuals(); // Update UI state
        }


        // --- Coin Flip Logic ---

        // Reset the coin flip game to its initial state
        function resetCoinFlip() {
            coinFlipActive = false;
            isCoinFlipping = false;
            coinFlipBet = 0;
            currentCoinFlipWinnings = 0;
            coinElement.classList.remove('flipping'); // Stop animation if active
            coinElement.textContent = '🪙'; // Reset to default coin emoji
            coinflipButton.textContent = 'Select Side & Flip';
            coinflipButton.disabled = true; // Disabled until side is chosen
            coinflipCashoutButton.disabled = true; // Disabled until a win occurs
            coinflipWinningsSpan.textContent = '0'; // Reset winnings display
            coinflipStatus.textContent = 'Choose Blue or Yellow!';
            coinflipBetInput.disabled = false; // Allow changing bet
            coinFlipChoice = null; // Reset choice
            // Reset button selections
            coinflipChooseBlueBtn.classList.remove('selected');
            coinflipChooseYellowBtn.classList.remove('selected');
            coinflipChooseBlueBtn.disabled = false;
            coinflipChooseYellowBtn.disabled = false;
        }

        // Set the player's chosen side for the coin flip
        function setCoinFlipChoice(choice) {
            if (isCoinFlipping || coinFlipActive) return; // Don't allow changing choice mid-round
            playSound('click');
            coinFlipChoice = choice;
            // Update button visuals
            if (choice === 'blue') {
                coinflipChooseBlueBtn.classList.add('selected');
                coinflipChooseYellowBtn.classList.remove('selected');
            } else {
                coinflipChooseYellowBtn.classList.add('selected');
                coinflipChooseBlueBtn.classList.remove('selected');
            }
            coinflipButton.disabled = false; // Enable flip button now that side is chosen
            coinflipStatus.textContent = `Selected ${choice === 'blue' ? 'Blue 🔵' : 'Yellow 🟡'}. Place your bet & Flip!`;
        }

        // Handle the coin flip action (either initial bet or subsequent flips)
        function handleCoinFlip() {
            if (isCoinFlipping) return; // Don't flip if already flipping

            if (!coinFlipChoice) { // Must choose a side first
                showMessage("Please choose Blue or Yellow first!", 2000);
                return;
            }

            const betAmount = parseInt(coinflipBetInput.value);

            // --- Initial Bet ---
            if (!coinFlipActive) {
                if (isNaN(betAmount) || betAmount <= 0) {
                    showMessage("Please enter a valid positive bet amount.", 2000); return;
                }
                if (betAmount > currency) {
                    showMessage("Not enough currency!", 2000); return;
                }
                coinFlipBet = betAmount; // Store the initial bet
                currency -= betAmount; // Deduct bet
                updateCurrencyDisplay('loss');
                currentCoinFlipWinnings = betAmount; // Start winnings streak with the bet amount
                coinFlipActive = true; // Mark round as active
                // Disable bet input and choice buttons for the duration of the round
                coinflipBetInput.disabled = true;
                coinflipButton.textContent = 'Flip Again'; // Change button text
                coinflipChooseBlueBtn.disabled = true;
                coinflipChooseYellowBtn.disabled = true;
            }
            // --- Subsequent Flips ---
            // Bet amount is already deducted, player is risking currentCoinFlipWinnings

            isCoinFlipping = true; // Start flipping animation state
            coinflipStatus.textContent = 'Flipping...';
            coinflipButton.disabled = true; // Disable flip/cashout during animation
            coinflipCashoutButton.disabled = true;
            coinElement.classList.add('flipping'); // Add animation class
            playSound('coin_flip');

            // Simulate flip result after animation duration
            setTimeout(() => {
                const resultIsBlue = Math.random() < 0.5; // 50/50 chance
                const resultEmoji = resultIsBlue ? '🔵' : '🟡';
                const resultColor = resultIsBlue ? 'blue' : 'yellow';

                coinElement.classList.remove('flipping'); // Remove animation class
                coinElement.textContent = resultEmoji; // Show result
                isCoinFlipping = false; // End flipping state

                // Check win/loss
                if (resultColor === coinFlipChoice) { // WIN
                    currentCoinFlipWinnings *= 2; // Double the winnings
                    coinflipStatus.textContent = `WIN! Current Winnings: ${formatWin(currentCoinFlipWinnings)}`;
                    coinflipButton.disabled = false; // Enable flip again
                    coinflipCashoutButton.disabled = false; // Enable cashout
                    coinflipWinningsSpan.textContent = formatWin(currentCoinFlipWinnings); // Update winnings display
                    playSound('win_small'); // Play win sound
                } else { // LOSS
                    coinflipStatus.textContent = `LOSS! It was ${resultEmoji}. You lost ${formatWin(currentCoinFlipWinnings)}.`;
                    totalLoss += coinFlipBet; // Add original bet to total loss
                    playSound('lose');
                    resetCoinFlip(); // Reset the game state
                    updateCurrencyDisplay(); // Update currency (no change type)
                }
                saveGameState(); // Save state after flip result
            }, 600); // Match animation duration
        }

        // Cash out the current coin flip winnings
        function cashOutCoinFlip() {
            if (!coinFlipActive || isCoinFlipping) return; // Can't cash out if not active or flipping

            const profit = currentCoinFlipWinnings - coinFlipBet; // Calculate profit
            currency += currentCoinFlipWinnings; // Add winnings back to currency
            totalGain += Math.max(0, profit); // Add profit to total gain

            showMessage(`Cashed out ${formatWin(currentCoinFlipWinnings)}! Profit: ${formatWin(profit)}`, 3000);
            playSound('win_medium'); // Play cashout sound
            addWinToLeaderboard('Coin Flip', profit); // Add profit to leaderboard
            resetCoinFlip(); // Reset the game
            updateCurrencyDisplay('win'); // Update currency (flash green)
            saveGameState();
        }


        // --- Minefield Logic ---

        // Create the minefield grid buttons
        function createMinefieldGrid() {
            minefieldGridElement.innerHTML = ''; // Clear previous grid
            for (let i = 0; i < MINEFIELD_TILES; i++) {
                const tile = document.createElement('button');
                tile.className = 'minefield-tile';
                tile.dataset.index = i;
                tile.textContent = '🔳'; // Initial hidden state symbol
                tile.disabled = true; // Disabled until game starts
                tile.addEventListener('click', () => handleMinefieldTileClick(i));
                minefieldGridElement.appendChild(tile);
            }
        }

        // Reset the minefield game to its initial state
        function resetMinefield() {
            minefieldActive = false;
            minefieldBet = 0;
            minefieldSafePicks = 0;
            minefieldMultiplier = 1.0;
            minefieldGrid = []; // Clear bomb locations
            minefieldRevealed = new Array(MINEFIELD_TILES).fill(false); // Reset revealed status
            // Reset button states
            minefieldStartButton.disabled = false;
            minefieldCashoutButton.disabled = true;
            minefieldBetInput.disabled = false;
            minefieldMultiplierSpan.textContent = minefieldMultiplier.toFixed(2); // Reset multiplier display
            minefieldStatus.textContent = 'Place your bet and start!';
            // Reset tile visuals
            const tiles = minefieldGridElement.querySelectorAll('.minefield-tile');
            tiles.forEach(tile => {
                tile.textContent = '🔳';
                tile.className = 'minefield-tile'; // Reset classes
                tile.disabled = true; // Disable tiles
                tile.style.transform = ''; // Reset any scaling
            });
        }

        // Generate bomb locations randomly
        function generateBombs(betAmount) {
            minefieldGrid = new Array(MINEFIELD_TILES).fill(0); // Initialize grid with safe tiles (0)
            minefieldRevealed = new Array(MINEFIELD_TILES).fill(false); // Reset revealed status
            let bombsPlaced = 0;
            while (bombsPlaced < MINEFIELD_BOMBS) {
                const index = Math.floor(Math.random() * MINEFIELD_TILES);
                if (minefieldGrid[index] === 0) { // Place bomb only if tile is currently safe
                    minefieldGrid[index] = 1; // Mark as bomb (1)
                    bombsPlaced++;
                }
            }
            minefieldBet = betAmount; // Store the bet for this round
            minefieldSafePicks = 0; // Reset safe pick counter
            minefieldMultiplier = 1.0; // Reset multiplier
            minefieldActive = true; // Mark game as active
        }

        // Start a new minefield game
        function startMinefield() {
            if (minefieldActive) return; // Don't start if already active

            const betAmount = parseInt(minefieldBetInput.value);
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", 2000); return;
            }
            if (betAmount > currency) {
                showMessage("Not enough currency!", 2000); return;
            }

            startTone();
            resetMinefield(); // Reset visuals and state before starting
            currency -= betAmount; // Deduct bet
            updateCurrencyDisplay('loss');
            generateBombs(betAmount); // Place bombs

            // Update UI for active game
            minefieldStartButton.disabled = true;
            minefieldCashoutButton.disabled = true; // Can't cash out before first pick
            minefieldBetInput.disabled = true;
            minefieldStatus.textContent = 'Click a tile to reveal!';
            // Enable all tiles for clicking
            const tiles = minefieldGridElement.querySelectorAll('.minefield-tile');
            tiles.forEach(tile => tile.disabled = false);
            saveGameState(); // Save state after starting
        }

        // Reveal all mine locations at the end of the game
        function revealAllMines(hitIndex = -1) { // hitIndex is the bomb the player clicked (if any)
            const tiles = minefieldGridElement.querySelectorAll('.minefield-tile');
            tiles.forEach((tile, index) => {
                tile.disabled = true; // Disable all tiles
                if (minefieldGrid[index] === 1) { // If it's a bomb
                    tile.textContent = '💣';
                    tile.classList.add('revealed', 'bomb');
                    if (index === hitIndex) { // Apply slight scale effect to the bomb that was hit
                        tile.style.transform = 'scale(1.1)';
                    }
                } else if (minefieldRevealed[index]) { // If it was a safe tile already revealed
                    tile.textContent = '🟩'; // Keep it green
                } else {
                    // Optionally reveal unclicked safe tiles differently, or leave them hidden
                    // tile.textContent = '⬜'; // Example: Reveal unclicked safe tiles as white squares
                }
            });
        }

        // Handle clicking on a minefield tile
        function handleMinefieldTileClick(index) {
            if (!minefieldActive || minefieldRevealed[index]) return; // Ignore clicks if game inactive or tile already revealed

            const tile = minefieldGridElement.querySelector(`.minefield-tile[data-index="${index}"]`);
            if (!tile || tile.disabled) return; // Ignore if tile not found or somehow disabled

            minefieldRevealed[index] = true; // Mark tile as revealed
            tile.disabled = true; // Disable the clicked tile

            if (minefieldGrid[index] === 1) { // --- BOMB HIT ---
                playSound('mine_bomb');
                tile.textContent = '💣';
                tile.classList.add('revealed', 'bomb'); // Apply bomb styles
                minefieldStatus.textContent = `BOOM! You hit a mine! Lost ${formatWin(minefieldBet)}.`;
                totalLoss += minefieldBet; // Add bet to total loss
                revealAllMines(index); // Show all other bombs
                minefieldActive = false; // Game over
                // Re-enable controls for new game
                minefieldStartButton.disabled = false;
                minefieldCashoutButton.disabled = true;
                minefieldBetInput.disabled = false;
                updateCurrencyDisplay(); // Update currency (no change type)
                saveGameState();
            } else { // --- SAFE PICK ---
                playSound('mine_reveal');
                tile.textContent = '🟩';
                tile.classList.add('revealed', 'safe'); // Apply safe styles
                minefieldSafePicks++;
                // Update multiplier based on number of safe picks
                minefieldMultiplier = MINEFIELD_MULTIPLIERS[minefieldSafePicks] || MINEFIELD_MULTIPLIERS[MINEFIELD_MULTIPLIERS.length - 1];
                minefieldMultiplierSpan.textContent = minefieldMultiplier.toFixed(2); // Update display
                minefieldCashoutButton.disabled = false; // Enable cashout now
                minefieldStatus.textContent = `Safe! Multiplier: ${minefieldMultiplier.toFixed(2)}x. Pick again or cash out.`;

                // Check for win condition (all safe tiles revealed)
                if (minefieldSafePicks === MINEFIELD_TILES - MINEFIELD_BOMBS) {
                    minefieldStatus.textContent = `Cleared the field! Max Win!`;
                    cashOutMinefield(); // Automatically cash out on max win
                } else {
                    saveGameState(); // Save progress after safe pick
                }
            }
        }

        // Cash out the current minefield winnings
        function cashOutMinefield() {
            if (!minefieldActive || minefieldSafePicks === 0) return; // Can't cash out if inactive or no picks made

            const winAmount = Math.floor(minefieldBet * minefieldMultiplier);
            const profit = winAmount - minefieldBet;
            currency += winAmount; // Add winnings to currency
            totalGain += Math.max(0, profit); // Add profit to total gain

            showMessage(`Cashed out ${formatWin(winAmount)}! Profit: ${formatWin(profit)}`, 3000);
            playSound('win_medium');
            addWinToLeaderboard('Mines', profit);
            revealAllMines(); // Show bomb locations after cashing out
            minefieldActive = false; // End the game
            // Re-enable controls
            minefieldStartButton.disabled = false;
            minefieldCashoutButton.disabled = true;
            minefieldBetInput.disabled = false;
            updateCurrencyDisplay('win'); // Update currency (flash green)
            saveGameState();
        }


        // --- Memory Game Logic ---

        // Create the memory game grid cards
        function createMemoryGrid() {
            memoryGridElement.innerHTML = ''; // Clear previous grid
            for (let i = 0; i < MEMORY_CARDS; i++) {
                const card = document.createElement('button');
                card.className = 'memory-card';
                card.dataset.index = i;
                card.disabled = true; // Disabled until game starts

                // Create front face (visible when hidden)
                const cardFaceFront = document.createElement('div');
                cardFaceFront.className = 'card-face card-front';
                cardFaceFront.textContent = '❓'; // Question mark for hidden state

                // Create back face (visible when revealed)
                const cardFaceBack = document.createElement('div');
                cardFaceBack.className = 'card-face card-back'; // Symbol will be added later

                card.appendChild(cardFaceFront);
                card.appendChild(cardFaceBack);
                card.addEventListener('click', () => handleMemoryCardClick(i));
                memoryGridElement.appendChild(card);
            }
        }

        // Reset the memory game to its initial state
        function resetMemoryGame() {
            memoryActive = false;
            memoryBet = 0;
            memoryGridSymbols = []; // Clear symbols
            memoryRevealedCards = []; // Clear revealed cards array
            memoryMatchedIndices = []; // Clear matched cards array
            memoryTriesLeft = 0;
            memoryIsChecking = false; // Reset checking flag
            // Reset button/input states
            memoryStartButton.disabled = false;
            memoryBetInput.disabled = false;
            memoryTriesLeftSpan.textContent = '--'; // Reset tries display
            memoryStatus.textContent = 'Place your bet and start!';
            // Reset card visuals
            const cards = memoryGridElement.querySelectorAll('.memory-card');
            cards.forEach(card => {
                card.classList.remove('revealed', 'matched', 'mismatched'); // Remove state classes
                card.disabled = true; // Disable cards
                const backFace = card.querySelector('.card-back');
                if (backFace) backFace.textContent = ''; // Clear symbol from back face
                const frontFace = card.querySelector('.card-front');
                if (frontFace) frontFace.textContent = '❓'; // Ensure front face shows question mark
            });
        }

        // Shuffle symbols and assign them to the grid
        function shuffleMemoryCards() {
            // Create pairs of symbols
            let symbolsToPlace = [];
            for (let i = 0; i < MEMORY_PAIRS; i++) {
                symbolsToPlace.push(MEMORY_SYMBOLS[i], MEMORY_SYMBOLS[i]);
            }
            // Shuffle the symbols array (Fisher-Yates shuffle)
            for (let i = symbolsToPlace.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [symbolsToPlace[i], symbolsToPlace[j]] = [symbolsToPlace[j], symbolsToPlace[i]]; // Swap elements
            }
            memoryGridSymbols = symbolsToPlace; // Store the shuffled symbols

            // Assign symbols to the back face of each card
            const cards = memoryGridElement.querySelectorAll('.memory-card');
            cards.forEach((card, index) => {
                const backFace = card.querySelector('.card-back');
                if (backFace) {
                    backFace.textContent = memoryGridSymbols[index];
                }
            });
        }

        // Start a new memory game
        function startMemoryGame() {
            if (memoryActive) return; // Don't start if already active

            const betAmount = parseInt(memoryBetInput.value);
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", 2000); return;
            }
            if (betAmount > currency) {
                showMessage("Not enough currency!", 2000); return;
            }

            startTone();
            resetMemoryGame(); // Reset state and visuals
            memoryBet = betAmount;
            currency -= betAmount; // Deduct bet
            updateCurrencyDisplay('loss');
            memoryActive = true;
            memoryTriesLeft = MEMORY_INITIAL_TRIES; // Set initial tries
            shuffleMemoryCards(); // Shuffle and assign symbols

            // Update UI for active game
            memoryStartButton.disabled = true;
            memoryBetInput.disabled = true;
            memoryTriesLeftSpan.textContent = memoryTriesLeft; // Display tries
            memoryStatus.textContent = 'Find the pairs!';
            // Enable cards for clicking
            const cards = memoryGridElement.querySelectorAll('.memory-card');
            cards.forEach(card => card.disabled = false);
            saveGameState(); // Save state after starting
        }

        // Handle clicking on a memory card
        function handleMemoryCardClick(index) {
            // Ignore clicks if game inactive, checking in progress, card already revealed, or card already matched
            if (!memoryActive || memoryIsChecking || memoryRevealedCards.includes(index) || memoryMatchedIndices.includes(index)) {
                return;
            }

            const card = memoryGridElement.querySelector(`.memory-card[data-index="${index}"]`);
            if (!card || card.disabled) return; // Ignore if card not found or disabled

            playSound('memory_flip');
            card.classList.add('revealed'); // Reveal the card (CSS handles the flip)
            memoryRevealedCards.push(index); // Add index to revealed array

            if (memoryRevealedCards.length === 2) { // Two cards revealed, check for match
                memoryIsChecking = true; // Prevent further clicks during check
                memoryStatus.textContent = 'Checking...';
                // Delay check slightly to allow player to see the second card
                setTimeout(checkMemoryMatch, 800);
            } else { // Only one card revealed
                memoryStatus.textContent = 'Pick another card.';
            }
        }

        // Check if the two revealed memory cards match
        function checkMemoryMatch() {
            if (memoryRevealedCards.length !== 2) { // Should not happen, but safety check
                memoryIsChecking = false; return;
            }

            const index1 = memoryRevealedCards[0];
            const index2 = memoryRevealedCards[1];
            const card1 = memoryGridElement.querySelector(`.memory-card[data-index="${index1}"]`);
            const card2 = memoryGridElement.querySelector(`.memory-card[data-index="${index2}"]`);

            if (!card1 || !card2) { // Safety check if cards somehow disappeared
                memoryIsChecking = false; memoryRevealedCards = []; return;
            }

            const symbol1 = memoryGridSymbols[index1];
            const symbol2 = memoryGridSymbols[index2];

            if (symbol1 === symbol2) { // --- MATCH ---
                playSound('memory_match');
                memoryStatus.textContent = `Matched ${symbol1}!`;
                card1.classList.add('matched'); // Apply matched style (optional visual cue)
                card2.classList.add('matched');
                card1.disabled = true; // Permanently disable matched cards
                card2.disabled = true;
                memoryMatchedIndices.push(index1, index2); // Add to matched array

                // Check for win condition (all cards matched)
                if (memoryMatchedIndices.length === MEMORY_CARDS) {
                    endMemoryGame(true); // Player won
                } else {
                    memoryIsChecking = false; // Allow next pick
                }
            } else { // --- MISMATCH ---
                playSound('memory_mismatch');
                memoryTriesLeft--; // Decrement tries
                memoryTriesLeftSpan.textContent = memoryTriesLeft; // Update display
                memoryStatus.textContent = `Mismatch! Tries left: ${memoryTriesLeft}`;
                card1.classList.add('mismatched'); // Apply mismatch style (e.g., red border/shake)
                card2.classList.add('mismatched');

                if (memoryTriesLeft <= 0) { // Check for lose condition (out of tries)
                    // Delay slightly before ending to show the mismatch
                    setTimeout(() => endMemoryGame(false), 600); // Player lost
                } else {
                    // Flip cards back after a delay
                    setTimeout(() => {
                        card1.classList.remove('revealed', 'mismatched'); // Hide cards again
                        card2.classList.remove('revealed', 'mismatched');
                        memoryIsChecking = false; // Allow next pick
                    }, 1000); // Delay before hiding mismatch
                }
            }

            memoryRevealedCards = []; // Clear revealed cards array for next turn
            saveGameState(); // Save state after check
        }

        // End the memory game (win or lose)
        function endMemoryGame(won) {
            memoryActive = false;
            memoryIsChecking = false;
            // Re-enable controls
            memoryStartButton.disabled = false;
            memoryBetInput.disabled = false;
            // Disable all cards
            const cards = memoryGridElement.querySelectorAll('.memory-card');
            cards.forEach(card => card.disabled = true);

            if (won) {
                const winAmount = memoryBet * MEMORY_WIN_MULTIPLIER;
                const profit = winAmount - memoryBet;
                currency += winAmount; // Add winnings
                totalGain += Math.max(0, profit); // Add profit
                memoryStatus.textContent = `YOU WIN! Found all pairs! Won ${formatWin(profit)}!`;
                playSound('memory_win');
                addWinToLeaderboard('Memory', profit);
                updateCurrencyDisplay('win'); // Update currency (flash green)
            } else {
                totalLoss += memoryBet; // Add bet to total loss
                memoryStatus.textContent = `Out of tries! You lost ${formatWin(memoryBet)}.`;
                playSound('memory_lose');
                // Optionally reveal all cards on loss
                cards.forEach((card, index) => {
                    if (!memoryMatchedIndices.includes(index)) { // Reveal only unmatched cards
                        card.classList.add('revealed');
                    }
                });
                updateCurrencyDisplay(); // Update currency (no flash)
            }
            saveGameState(); // Save final state
        }


        // --- Horse Race Logic (Right-to-Left) ---

        // Create the horse selection buttons UI
        function createHorseSelectionUI() {
            horseraceSelectionContainer.innerHTML = ''; // Clear previous buttons
            HORSE_NAMES.forEach((name, index) => {
                const button = document.createElement('button');
                button.className = 'horse-select-btn';
                button.dataset.horseIndex = index;

                // Color indicator span
                const colorIndicator = document.createElement('span');
                colorIndicator.className = 'horse-color-indicator';
                colorIndicator.style.backgroundColor = HORSE_COLORS[index % HORSE_COLORS.length];

                button.appendChild(colorIndicator);
                button.appendChild(document.createTextNode(` ${index + 1}. ${name}`)); // Add space

                button.addEventListener('click', () => {
                    if (horseraceActive) return; // Don't allow selection during race
                    playSound('click');
                    // Remove selected class from all buttons
                    horseraceSelectionContainer.querySelectorAll('.horse-select-btn').forEach(btn => btn.classList.remove('selected'));
                    // Add selected class to clicked button
                    button.classList.add('selected');
                    selectedHorseIndex = index; // Update selected horse state
                    horseraceStatus.textContent = `Selected Horse #${index + 1}: ${name}`;
                });
                horseraceSelectionContainer.appendChild(button);
            });
        }

        // Create the horse elements and lanes within the track
        function createHorses() {
            horseraceTrack.innerHTML = ''; // Clear previous horses/lanes/finish line
            horseElements = []; // Clear the array
            horseLaneElements = []; // Clear the lane array

            // Check if track is actually visible and has height (important for positioning)
            if (horseraceTrack.clientHeight <= 0) {
                console.warn("Track height not available for horse creation.");
                // Don't retry here, rely on setActiveTab to call it when visible
                return;
            }

            // Create lanes and horses
            for (let i = 0; i < NUM_HORSES; i++) {
                const lane = document.createElement('div');
                lane.className = 'horse-lane';

                const horse = document.createElement('div');
                horse.className = 'horse';
                horse.dataset.horseId = i;
                horse.textContent = '🐎'; // Horse emoji
                horse.style.color = HORSE_COLORS[i % HORSE_COLORS.length]; // Assign color
                horse.style.right = '10px'; // Start position (RIGHT SIDE)

                lane.appendChild(horse);
                horseraceTrack.appendChild(lane);
                horseElements.push(horse); // Store horse reference
                horseLaneElements.push(lane); // Store lane reference
            }

            // Add finish line (on the LEFT side)
            const finishLine = document.createElement('div');
            finishLine.id = 'horserace-finish-line';
            horseraceTrack.appendChild(finishLine);
        }

        // Reset the horse race game to its initial state
        function resetHorserace() {
            if (raceAnimationId) {
                cancelAnimationFrame(raceAnimationId); // Stop any ongoing race animation
                raceAnimationId = null;
            }
            horseraceActive = false;
            horseraceBet = 0;
            // Don't reset selectedHorseIndex here, allow selection before starting
            // selectedHorseIndex = -1;
            horsePositions = new Array(NUM_HORSES).fill(10); // Reset positions to start (10px from right)
            raceFrameCounter = 0; // Reset trail counter

            // Reset horse elements visually
            horseElements.forEach((horse, index) => {
                if (horse) {
                    horse.style.right = `${horsePositions[index]}px`; // Set initial right style
                    horse.classList.remove('animate-pulse'); // Remove winner pulse if applied
                }
            });
            // Remove any existing trails
            horseraceTrack.querySelectorAll('.horse-trail').forEach(trail => trail.remove());

            // Reset selection buttons (keep selection if made)
            // horseraceSelectionContainer.querySelectorAll('.horse-select-btn').forEach(btn => btn.classList.remove('selected'));

            // Re-enable controls
            horseraceStartButton.disabled = false;
            horseraceBetInput.disabled = false;
            horseraceSelectionContainer.querySelectorAll('.horse-select-btn').forEach(btn => btn.disabled = false); // Enable selection buttons
            // Update status only if no horse is selected yet
            if (selectedHorseIndex === -1) {
                horseraceStatus.textContent = 'Place your bet and pick a horse!';
            } else {
                horseraceStatus.textContent = `Selected Horse #${selectedHorseIndex + 1}: ${HORSE_NAMES[selectedHorseIndex]}. Place bet & start!`;
            }
        }

        // Start the horse race
        function startHorserace() {
            if (horseraceActive) return; // Don't start if already active

            const betAmount = parseInt(horseraceBetInput.value);
            if (isNaN(betAmount) || betAmount <= 0) { showMessage("Please enter a valid positive bet amount.", 2000); return; }
            if (betAmount > currency) { showMessage("Not enough currency!", 2000); return; }
            if (selectedHorseIndex < 0 || selectedHorseIndex >= NUM_HORSES) { showMessage("Please select a horse to bet on.", 2000); return; }

            // Ensure horses are created if they weren't already
            if (horseElements.length === 0) {
                createHorses();
                if (horseElements.length === 0) { // Still couldn't create them (e.g., track hidden)
                    showMessage("Error initializing race track. Try switching tabs.", 3000);
                    return;
                }
            }

            startTone();
            playSound('race_start');
            horseraceBet = betAmount;
            currency -= betAmount;
            updateCurrencyDisplay('loss');

            horseraceActive = true;
            // Disable controls during race
            horseraceStartButton.disabled = true;
            horseraceBetInput.disabled = true;
            horseraceSelectionContainer.querySelectorAll('.horse-select-btn').forEach(btn => btn.disabled = true);
            horseraceStatus.textContent = 'And they\'re off!';

            // Reset positions and visuals before starting animation
            horsePositions = new Array(NUM_HORSES).fill(10); // Reset positions (10px from right)
            horseElements.forEach((horse, i) => {
                if(horse) {
                    horse.style.right = `${horsePositions[i]}px`;
                    horse.classList.remove('animate-pulse');
                }
            });
            horseraceTrack.querySelectorAll('.horse-trail').forEach(trail => trail.remove()); // Clear old trails
            raceFrameCounter = 0; // Reset frame counter for trails

            const trackWidth = horseraceTrack.clientWidth;
            // Finish line is positioned 20px from left + 5px width = 25px effective position
            const finishLinePos = 25; // Target position (pixels from left) for finish

            if (trackWidth <= 0) {
                console.error("Cannot start race: Track width is zero.");
                horseraceStatus.textContent = "Error starting race (track size).";
                resetHorserace(); return;
            }

            let startTime = null;

            // --- Race Animation Loop (Right-to-Left) ---
            function raceStep(timestamp) {
                if (!startTime) startTime = timestamp;
                if (!horseraceActive) return; // Stop if game reset externally

                let winner = -1;
                raceFrameCounter++;

                horsePositions = horsePositions.map((pos, i) => {
                    // Calculate current position from the left edge for finish check
                    const horseWidth = horseElements[i]?.offsetWidth || 20; // Get actual or estimate width
                    const currentLeftPos = trackWidth - pos - horseWidth;
                    if (currentLeftPos <= finishLinePos) return pos; // Stop advancing if finished

                    // Random advancement per frame (move right position value)
                    const advancement = Math.random() * 2.5 + 0.5;
                    const newPos = pos + advancement; // Increase distance from right edge

                    // Calculate visual position from left for clamping and finish check
                    const visualLeftPos = trackWidth - newPos - horseWidth;

                    if(horseElements[i]) {
                        horseElements[i].style.right = `${newPos}px`; // Update right style

                        // Create trail particle occasionally
                        if (raceFrameCounter % 4 === 0) {
                            const trail = document.createElement('div');
                            trail.className = 'horse-trail';
                            trail.style.backgroundColor = HORSE_COLORS[i % HORSE_COLORS.length];
                            // Position trail slightly behind the horse (adjust based on 'right' style)
                            trail.style.right = `${newPos - 5}px`;
                            trail.style.top = '50%';
                            trail.style.transform = 'translateY(-50%)';
                            if(horseLaneElements[i]) {
                                horseLaneElements[i].appendChild(trail);
                            }
                            trail.addEventListener('animationend', () => trail.remove());
                        }
                        // Play step sound less frequently
                        if (raceFrameCounter % 10 === 0) playSound('race_step');
                    }

                    // Check if this horse crossed the finish line (based on left position)
                    if (visualLeftPos <= finishLinePos && winner === -1) {
                        winner = i;
                    }
                    return newPos; // Return updated right position
                });

                // Check if a winner was determined
                if (winner !== -1) {
                    finishRace(winner); // Finish the race
                } else {
                    raceAnimationId = requestAnimationFrame(raceStep); // Continue animation
                }
            }

            raceAnimationId = requestAnimationFrame(raceStep); // Start the first frame
            saveGameState();
        }

        // Finish the horse race and determine payout
        function finishRace(winnerIndex) {
            if (!horseraceActive) return; // Prevent finishing multiple times

            cancelAnimationFrame(raceAnimationId); // Stop animation loop
            raceAnimationId = null;
            horseraceActive = false;

            const winnerName = HORSE_NAMES[winnerIndex];
            const playerWon = winnerIndex === selectedHorseIndex;

            // Highlight winner
            if(horseElements[winnerIndex]) {
                horseElements[winnerIndex].classList.add('animate-pulse');
            }

            if (playerWon) {
                const winAmount = horseraceBet * HORSERACE_WIN_MULTIPLIER;
                const profit = winAmount - horseraceBet;
                currency += winAmount;
                totalGain += Math.max(0, profit);
                horseraceStatus.textContent = `Horse #${winnerIndex + 1} (${winnerName}) wins! You won ${formatWin(profit)}!`;
                playSound('race_win');
                addWinToLeaderboard('Race', profit);
                updateCurrencyDisplay('win');
            } else {
                totalLoss += horseraceBet;
                horseraceStatus.textContent = `Horse #${winnerIndex + 1} (${winnerName}) wins! You lost ${formatWin(horseraceBet)}.`;
                playSound('lose');
                updateCurrencyDisplay();
            }

            // Re-enable controls after a short delay
            setTimeout(() => {
                horseraceStartButton.disabled = false;
                horseraceBetInput.disabled = false;
                horseraceSelectionContainer.querySelectorAll('.horse-select-btn').forEach(btn => btn.disabled = false);
            }, 1500);

            saveGameState();
        }


        // --- Roulette Logic ---

        // Populate ROULETTE_NUMBER_COLORS map
        function initializeRouletteColors() {
            const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
            ROULETTE_NUMBERS.forEach(num => {
                if (num === 0) {
                    ROULETTE_NUMBER_COLORS[num] = 'green';
                } else if (redNumbers.includes(num)) {
                    ROULETTE_NUMBER_COLORS[num] = 'red';
                } else {
                    ROULETTE_NUMBER_COLORS[num] = 'black';
                }
            });
        }

        // Create the number buttons for the roulette betting grid
        function createRouletteBettingGrid() {
            rouletteInsideBetsContainer.innerHTML = ''; // Clear previous grid
            // Add button for 0
            const zeroButton = document.createElement('button');
            zeroButton.className = 'roulette-bet-btn green';
            zeroButton.textContent = '0';
            zeroButton.dataset.betType = 'number';
            zeroButton.dataset.betValue = '0';
            zeroButton.style.gridColumn = 'span 3'; // Make 0 span full width
            zeroButton.addEventListener('click', () => selectRouletteBet('number', 0, zeroButton));
            rouletteInsideBetsContainer.appendChild(zeroButton);

            // Add buttons for 1-36
            for (let i = 1; i <= 36; i++) {
                const button = document.createElement('button');
                const color = ROULETTE_NUMBER_COLORS[i];
                button.className = `roulette-bet-btn ${color}`;
                button.textContent = i;
                button.dataset.betType = 'number';
                button.dataset.betValue = i;
                button.addEventListener('click', () => selectRouletteBet('number', i, button));
                rouletteInsideBetsContainer.appendChild(button);
            }
        }

        // Reset the roulette game state and UI
        function resetRoulette() {
            rouletteIsSpinning = false;
            rouletteSelectedBet = null; // Clear selected bet
            rouletteSpinButton.disabled = false; // Enable spin button
            rouletteBetInput.disabled = false; // Enable bet input
            rouletteStatus.textContent = 'Place your bet!';
            rouletteResultDisplay.textContent = '?'; // Reset result display
            rouletteResultDisplay.className = ''; // Reset result color class
            // Re-apply base classes for the result display
            rouletteResultDisplay.classList.add('flex', 'items-center', 'justify-center', 'absolute', 'top-1/2', 'left-1/2', 'transform', '-translate-x-1/2', '-translate-y-1/2', 'w-16', 'h-16', 'bg-opacity-80', 'rounded-full', 'text-2xl', 'font-bold', 'text-white', 'z-10', 'border-4');
            rouletteResultDisplay.style.backgroundColor = 'rgba(20, 20, 20, 0.8)'; // Reset background
            rouletteResultDisplay.style.borderColor = '#4a4a4a'; // Reset border color

            // Reset wheel rotation visually without transition for the next spin calculation
            // rouletteWheel.style.transition = 'none'; // Temporarily disable transition
            // rouletteWheel.style.transform = `rotate(${currentWheelAngle % 360}deg)`; // Set to remainder angle
            // void rouletteWheel.offsetWidth; // Force reflow
            // rouletteWheel.style.transition = ''; // Re-enable transition from CSS

            // Enable betting buttons
            rouletteInsideBetsContainer.querySelectorAll('.roulette-bet-btn').forEach(btn => btn.disabled = false);
            rouletteOutsideBetsContainer.querySelectorAll('.roulette-bet-btn').forEach(btn => btn.disabled = false);
            // Clear selection highlight
            document.querySelectorAll('.roulette-bet-btn.selected').forEach(btn => btn.classList.remove('selected'));
            rouletteCurrentBetSpan.textContent = 'None';
        }

        // Handle selecting a bet type/value
        function selectRouletteBet(type, value, clickedButton) {
            if (rouletteIsSpinning) return; // Don't allow changing bet while spinning
            playSound('click');

            // Clear previous selection
            document.querySelectorAll('.roulette-bet-btn.selected').forEach(btn => btn.classList.remove('selected'));

            // Set new selection
            rouletteSelectedBet = { type: type, value: value };
            if (clickedButton) {
                clickedButton.classList.add('selected'); // Highlight selected button
            }

            // Update status display
            let betText = '';
            if (type === 'number') betText = `Number ${value}`;
            else betText = type.charAt(0).toUpperCase() + type.slice(1); // Capitalize type name
            rouletteCurrentBetSpan.textContent = betText;
            rouletteStatus.textContent = `Betting on ${betText}. Spin the wheel!`;
        }

        // Spin the roulette wheel - REVISED
        function spinRouletteWheel() {
            if (rouletteIsSpinning) return; // Don't spin if already spinning

            const betAmount = parseInt(rouletteBetInput.value);
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", 2000); return;
            }
            if (betAmount > currency) {
                showMessage("Not enough currency!", 2000); return;
            }
            if (!rouletteSelectedBet) {
                showMessage("Please select a bet type first!", 2000); return;
            }

            startTone();
            playSound('roulette_spin');
            rouletteBet = betAmount;
            currency -= betAmount;
            updateCurrencyDisplay('loss');

            rouletteIsSpinning = true;
            // Disable controls during spin
            rouletteSpinButton.disabled = true;
            rouletteBetInput.disabled = true;
            rouletteInsideBetsContainer.querySelectorAll('.roulette-bet-btn').forEach(btn => btn.disabled = true);
            rouletteOutsideBetsContainer.querySelectorAll('.roulette-bet-btn').forEach(btn => btn.disabled = true);
            rouletteStatus.textContent = 'Spinning... No more bets!';
            rouletteResultDisplay.textContent = '...'; // Indicate spinning

            // --- Calculate Spin Result ---
            const winningNumberIndex = Math.floor(Math.random() * ROULETTE_NUMBERS.length);
            const winningNumber = ROULETTE_NUMBERS[winningNumberIndex];
            const winningColor = ROULETTE_NUMBER_COLORS[winningNumber];

            // --- Calculate Target Angle ---
            const numberAngle = 360 / ROULETTE_NUMBERS.length;
            // Calculate the base angle for the winning number segment's center (0 degrees is top)
            const winningSegmentCenterAngle = (winningNumberIndex * numberAngle) + (numberAngle / 2);
            // Calculate the angle needed to rotate the wheel so the winning segment center aligns with the top pointer (0 degrees)
            const angleToWinningNumber = 360 - winningSegmentCenterAngle;

            // Add multiple full rotations for visual effect (e.g., 5-7 rotations)
            const fullRotations = (5 + Math.floor(Math.random() * 3)) * 360;

            // Calculate the final target angle based on the *current* visual angle plus rotations and offset
            // This ensures the wheel spins forward from its current position.
            const targetAngle = currentWheelAngle + fullRotations + angleToWinningNumber;

            // Apply the spin animation using CSS transition
            rouletteWheel.style.transform = `rotate(${targetAngle}deg)`;

            // Simulate ball bounce sounds during spin
            let ballSoundInterval = setInterval(() => {
                playSound('roulette_ball');
            }, 150 + Math.random() * 150); // Random interval for ball sounds


            // --- Determine Result after Animation ---
            setTimeout(() => {
                clearInterval(ballSoundInterval); // Stop ball sounds
                rouletteIsSpinning = false; // Mark spinning as complete

                // Update the current angle state for the next spin calculation
                currentWheelAngle = targetAngle;

                // Display winning number and color
                rouletteResultDisplay.textContent = winningNumber;
                rouletteResultDisplay.className = ''; // Clear previous color classes
                rouletteResultDisplay.classList.add('flex', 'items-center', 'justify-center', 'absolute', 'top-1/2', 'left-1/2', 'transform', '-translate-x-1/2', '-translate-y-1/2', 'w-16', 'h-16', 'bg-opacity-80', 'rounded-full', 'text-2xl', 'font-bold', 'text-white', 'z-10', 'border-4'); // Re-apply base classes
                rouletteResultDisplay.style.backgroundColor = winningColor === 'red' ? '#ef4444' : winningColor === 'black' ? '#1f2937' : '#10b981';
                rouletteResultDisplay.style.borderColor = winningColor === 'red' ? '#dc2626' : winningColor === 'black' ? '#111827' : '#059669';


                // Calculate payout
                let winAmount = 0;
                let playerWins = false;
                const betType = rouletteSelectedBet.type;
                const betValue = rouletteSelectedBet.value;

                if (betType === 'number' && betValue === winningNumber) {
                    winAmount = rouletteBet * 36; // 35:1 payout + original bet
                    playerWins = true;
                } else if (betType === 'red' && winningColor === 'red') {
                    winAmount = rouletteBet * 2; // 1:1 payout + original bet
                    playerWins = true;
                } else if (betType === 'black' && winningColor === 'black') {
                    winAmount = rouletteBet * 2;
                    playerWins = true;
                } else if (betType === 'odd' && winningNumber !== 0 && winningNumber % 2 !== 0) {
                    winAmount = rouletteBet * 2;
                    playerWins = true;
                } else if (betType === 'even' && winningNumber !== 0 && winningNumber % 2 === 0) {
                    winAmount = rouletteBet * 2;
                    playerWins = true;
                } else if (betType === 'low' && winningNumber >= 1 && winningNumber <= 18) {
                    winAmount = rouletteBet * 2;
                    playerWins = true;
                } else if (betType === 'high' && winningNumber >= 19 && winningNumber <= 36) {
                    winAmount = rouletteBet * 2;
                    playerWins = true;
                }

                // Update currency and stats
                if (playerWins) {
                    const profit = winAmount - rouletteBet;
                    currency += winAmount;
                    totalGain += Math.max(0, profit);
                    rouletteStatus.textContent = `WIN! Number ${winningNumber} (${winningColor}). You won ${formatWin(profit)}!`;
                    playSound('roulette_win');
                    addWinToLeaderboard('Roulette', profit);
                    updateCurrencyDisplay('win');
                } else {
                    totalLoss += rouletteBet;
                    rouletteStatus.textContent = `LOSE! Number ${winningNumber} (${winningColor}). You lost ${formatWin(rouletteBet)}.`;
                    playSound('lose');
                    updateCurrencyDisplay();
                }

                // Re-enable controls after a short delay
                setTimeout(() => {
                    resetRoulette(); // Fully reset the game state for the next round
                }, 1500);

                saveGameState();

            }, ROULETTE_SPIN_DURATION); // Match CSS transition duration
        }


        // --- Blackjack Logic ---

        /**
        * Creates a standard 52-card deck.
        * @returns {Array<Object>} An array of card objects { rank: string, suit: string }.
        */
        function createBlackjackDeck() {
            const deck = [];
            for (const suit of blackjackSuits) {
                for (const rank of blackjackRanks) {
                    deck.push({ rank, suit });
                }
            }
            return deck;
        }

        /**
        * Shuffles an array in place using the Fisher-Yates algorithm.
        * @param {Array} array The array to shuffle.
        */
        function shuffleDeck(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
        }

        /**
        * Gets the numerical value of a Blackjack card rank.
        * @param {string} rank The card rank ('2'-'9', 'T', 'J', 'Q', 'K', 'A').
        * @returns {number} The numerical value (Ace is 11 initially).
        */
        function getBlackjackCardValue(rank) {
            if (['T', 'J', 'Q', 'K'].includes(rank)) {
                return 10;
            } else if (rank === 'A') {
                return 11; // Ace is initially 11
            } else {
                return parseInt(rank);
            }
        }

        /**
        * Calculates the total value of a Blackjack hand, handling Aces correctly.
        * @param {Array<Object>} hand An array of card objects.
        * @returns {number} The calculated hand value.
        */
        function calculateBlackjackHandValue(hand) {
            let value = 0;
            let aceCount = 0;
            for (const card of hand) {
                value += getBlackjackCardValue(card.rank);
                if (card.rank === 'A') {
                    aceCount++;
                }
            }
            // Adjust for Aces if the total value exceeds 21
            while (value > BLACKJACK_TARGET_SCORE && aceCount > 0) {
                value -= 10; // Change an Ace from 11 to 1
                aceCount--;
            }
            return value;
        }

        /**
        * Creates an HTML element representing a playing card.
        * @param {Object} card The card object { rank: string, suit: string }.
        * @param {boolean} [isHidden=false] Whether the card should be hidden (face down).
        * @returns {HTMLElement} The card div element.
        */
        function createBlackjackCardElement(card, isHidden = false) {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'blackjack-card';
            if (isHidden) {
                cardDiv.classList.add('hidden');
                // Add placeholder content or leave empty for hidden card
                cardDiv.innerHTML = `<span>?</span><span>?</span>`;
            } else {
                const rankSpan = document.createElement('span');
                rankSpan.textContent = card.rank === 'T' ? '10' : card.rank; // Display '10' for Ten

                const suitSpan = document.createElement('span');
                suitSpan.textContent = card.suit;

                // Add color class based on suit
                if (['♥', '♦'].includes(card.suit)) {
                    cardDiv.classList.add('suit-red');
                } else {
                    cardDiv.classList.add('suit-black');
                }

                cardDiv.appendChild(rankSpan);
                cardDiv.appendChild(suitSpan);
            }
            return cardDiv;
        }

        /**
        * Deals a single card from the deck to a specified hand.
        * @param {Array<Object>} hand The hand to deal to (player or dealer).
        */
        function dealBlackjackCard(hand) {
            if (blackjackDeck.length > 0) {
                hand.push(blackjackDeck.pop());
            } else {
                console.error("Deck is empty!"); // Should ideally not happen with a single deck game
                showMessage("Error: Deck empty!", 2000);
            }
        }

        /**
        * Resets the Blackjack game state and UI.
        * @param {boolean} [refundBet=false] - If true, refunds the current bet (used when switching tabs).
        */
        function resetBlackjack(refundBet = false) {
            if (refundBet && blackjackActive && blackjackBet > 0) {
                currency += blackjackBet; // Refund bet if game was active and reset by tab switch
                updateCurrencyDisplay(); // Update display without flash
            }

            blackjackActive = false;
            blackjackBet = 0;
            blackjackDeck = [];
            blackjackPlayerHand = [];
            blackjackDealerHand = [];
            blackjackPlayerScore = 0;
            blackjackDealerScore = 0;
            blackjackPlayerBusted = false;
            blackjackDealerBusted = false;
            blackjackPlayerBlackjack = false;
            blackjackDealerBlackjack = false;

            // Clear UI elements
            blackjackPlayerHandElement.innerHTML = '';
            blackjackDealerHandElement.innerHTML = '';
            blackjackPlayerScoreElement.textContent = '0';
            blackjackDealerScoreElement.textContent = '0';
            blackjackPlayerScoreElement.parentElement.classList.remove('busted', 'blackjack');
            blackjackDealerScoreElement.parentElement.classList.remove('busted', 'blackjack');
            blackjackStatus.textContent = 'Place your bet and Deal!';

            // Reset button states
            blackjackDealButton.disabled = false;
            blackjackHitButton.disabled = true;
            blackjackStandButton.disabled = true;
            blackjackBetInput.disabled = false; // Allow changing bet
        }

        /**
        * Updates the Blackjack UI based on the current game state.
        * @param {boolean} [hideDealerCard=false] - If true, hides the dealer's second card.
        */
        function updateBlackjackUI(hideDealerCard = false) {
            // Update Player Hand and Score
            blackjackPlayerHandElement.innerHTML = '';
            blackjackPlayerHand.forEach(card => {
                blackjackPlayerHandElement.appendChild(createBlackjackCardElement(card));
            });
            blackjackPlayerScore = calculateBlackjackHandValue(blackjackPlayerHand);
            blackjackPlayerScoreElement.textContent = blackjackPlayerScore;
            // Update player score display style
            blackjackPlayerScoreElement.parentElement.classList.remove('busted', 'blackjack');
            if (blackjackPlayerBusted) {
                blackjackPlayerScoreElement.parentElement.classList.add('busted');
            } else if (blackjackPlayerBlackjack && blackjackPlayerHand.length === 2) {
                blackjackPlayerScoreElement.parentElement.classList.add('blackjack');
            }

            // Update Dealer Hand and Score
            blackjackDealerHandElement.innerHTML = '';
            let visibleDealerScore = 0;
            blackjackDealerHand.forEach((card, index) => {
                const isHidden = hideDealerCard && index === 1;
                blackjackDealerHandElement.appendChild(createBlackjackCardElement(card, isHidden));
                if (!isHidden) {
                    // Calculate visible score only for shown cards
                    visibleDealerScore += getBlackjackCardValue(card.rank);
                    // Handle Ace adjustment for visible score if needed (less common but for accuracy)
                    if (card.rank === 'A' && visibleDealerScore > BLACKJACK_TARGET_SCORE) {
                        visibleDealerScore -= 10;
                    }
                }
            });
            // Display either the visible score or the final score if game is over
            blackjackDealerScore = calculateBlackjackHandValue(blackjackDealerHand); // Full score calculation
            blackjackDealerScoreElement.textContent = hideDealerCard ? visibleDealerScore : blackjackDealerScore;
            // Update dealer score display style (only show final state like bust/blackjack when game ends)
            blackjackDealerScoreElement.parentElement.classList.remove('busted', 'blackjack');
            if (!hideDealerCard) { // Only show final status when all cards revealed
                if (blackjackDealerBusted) {
                    blackjackDealerScoreElement.parentElement.classList.add('busted');
                } else if (blackjackDealerBlackjack && blackjackDealerHand.length === 2) {
                    blackjackDealerScoreElement.parentElement.classList.add('blackjack');
                }
            }
        }

        /**
        * Starts a new round of Blackjack.
        */
        function startBlackjackGame() {
            if (blackjackActive) return; // Don't start if already active

            const betAmount = parseInt(blackjackBetInput.value);
            if (isNaN(betAmount) || betAmount <= 0) {
                showMessage("Please enter a valid positive bet amount.", 2000); return;
            }
            if (betAmount > currency) {
                showMessage("Not enough currency!", 2000); return;
            }

            startTone();
            playSound('blackjack_deal');
            resetBlackjack(); // Reset previous game state

            blackjackActive = true;
            blackjackBet = betAmount;
            currency -= betAmount;
            updateCurrencyDisplay('loss');

            // Create and shuffle deck
            blackjackDeck = createBlackjackDeck();
            shuffleDeck(blackjackDeck);

            // Deal initial hands
            dealBlackjackCard(blackjackPlayerHand);
            dealBlackjackCard(blackjackDealerHand);
            dealBlackjackCard(blackjackPlayerHand);
            dealBlackjackCard(blackjackDealerHand);

            // Calculate initial scores and check for immediate Blackjacks
            blackjackPlayerScore = calculateBlackjackHandValue(blackjackPlayerHand);
            blackjackDealerScore = calculateBlackjackHandValue(blackjackDealerHand); // Calculate full dealer score now
            blackjackPlayerBlackjack = (blackjackPlayerScore === BLACKJACK_TARGET_SCORE && blackjackPlayerHand.length === 2);
            blackjackDealerBlackjack = (blackjackDealerScore === BLACKJACK_TARGET_SCORE && blackjackDealerHand.length === 2);

            // Update UI, hiding dealer's second card initially
            updateBlackjackUI(true);

            // Disable bet input and deal button, enable hit/stand
            blackjackBetInput.disabled = true;
            blackjackDealButton.disabled = true;
            blackjackHitButton.disabled = false;
            blackjackStandButton.disabled = false;

            // Handle immediate Blackjack scenarios
            if (blackjackPlayerBlackjack || blackjackDealerBlackjack) {
                // If either has Blackjack, the game ends immediately after revealing dealer card
                setTimeout(() => determineBlackjackWinner(), 500); // Slight delay to show hands
            } else {
                blackjackStatus.textContent = 'Your turn: Hit or Stand?';
            }
            saveGameState();
        }

        /**
        * Handles the player clicking the "Hit" button.
        */
        function blackjackHit() {
            if (!blackjackActive) return;
            playSound('blackjack_hit');

            dealBlackjackCard(blackjackPlayerHand);
            blackjackPlayerScore = calculateBlackjackHandValue(blackjackPlayerHand);
            blackjackPlayerBusted = blackjackPlayerScore > BLACKJACK_TARGET_SCORE;

            updateBlackjackUI(true); // Keep dealer card hidden

            if (blackjackPlayerBusted) {
                blackjackStatus.textContent = `Busted! (${blackjackPlayerScore})`;
                playSound('blackjack_bust');
                determineBlackjackWinner(); // End game immediately if player busts
            } else {
                blackjackStatus.textContent = 'Hit or Stand?';
            }
            saveGameState();
        }

        /**
        * Handles the player clicking the "Stand" button.
        */
        function blackjackStand() {
            if (!blackjackActive) return;
            playSound('click'); // Simple click sound for stand

            // Disable player actions
            blackjackHitButton.disabled = true;
            blackjackStandButton.disabled = true;

            // Reveal dealer's hidden card and proceed with dealer's turn
            blackjackStatus.textContent = "Dealer's turn...";
            updateBlackjackUI(false); // Reveal dealer's second card

            // Delay dealer's turn slightly for visual pacing
            setTimeout(dealerTurn, 1000);
        }

        /**
        * Executes the dealer's turn according to Blackjack rules.
        */
        function dealerTurn() {
            if (!blackjackActive) return; // Check if game ended prematurely (e.g., player Blackjack)

            // Reveal dealer's full hand first if it wasn't already
            updateBlackjackUI(false);

            // Dealer hits until score is DEALER_STAND_SCORE (17) or higher
            if (blackjackDealerScore < DEALER_STAND_SCORE) {
                blackjackStatus.textContent = 'Dealer hits...';
                playSound('blackjack_hit');
                dealBlackjackCard(blackjackDealerHand);
                blackjackDealerScore = calculateBlackjackHandValue(blackjackDealerHand);
                blackjackDealerBusted = blackjackDealerScore > BLACKJACK_TARGET_SCORE;
                updateBlackjackUI(false); // Update UI with new card

                if (blackjackDealerBusted) {
                    blackjackStatus.textContent = `Dealer Busted! (${blackjackDealerScore})`;
                    playSound('blackjack_bust');
                    determineBlackjackWinner(); // End game if dealer busts
                } else {
                    // Delay next dealer action for pacing
                    setTimeout(dealerTurn, 1000);
                }
            } else {
                // Dealer stands
                blackjackStatus.textContent = `Dealer stands (${blackjackDealerScore}).`;
                determineBlackjackWinner(); // Determine winner after dealer stands
            }
            saveGameState();
        }

        /**
        * Determines the winner of the Blackjack round and updates the state.
        */
        function determineBlackjackWinner() {
            if (!blackjackActive) return; // Ensure game is active

            // Reveal dealer's full hand if it wasn't already (e.g., player Blackjack)
            updateBlackjackUI(false);

            blackjackActive = false; // Mark game as ended
            blackjackHitButton.disabled = true;
            blackjackStandButton.disabled = true;
            blackjackDealButton.disabled = false; // Enable Deal for next round
            blackjackBetInput.disabled = false; // Enable bet input for next round

            let winAmount = 0;
            let statusMessage = '';
            let outcomeSound = 'lose'; // Default sound

            // Player Blackjack scenarios
            if (blackjackPlayerBlackjack) {
                if (blackjackDealerBlackjack) {
                    statusMessage = `Push! Both have Blackjack! Bet ${formatWin(blackjackBet)} returned.`;
                    winAmount = blackjackBet; // Return original bet
                    outcomeSound = 'blackjack_push';
                } else {
                    statusMessage = `Blackjack! You win ${formatWin(blackjackBet * (BLACKJACK_PAYOUT_MULTIPLIER - 1))}!`;
                    winAmount = Math.floor(blackjackBet * BLACKJACK_PAYOUT_MULTIPLIER); // 3:2 payout
                    outcomeSound = 'blackjack_blackjack';
                }
            }
            // Dealer Blackjack scenario (player does not have Blackjack)
            else if (blackjackDealerBlackjack) {
                statusMessage = `Dealer Blackjack! You lose ${formatWin(blackjackBet)}.`;
                winAmount = 0; // Player loses bet
                outcomeSound = 'lose';
            }
            // Bust scenarios
            else if (blackjackPlayerBusted) {
                statusMessage = `You Busted! (${blackjackPlayerScore}). You lose ${formatWin(blackjackBet)}.`;
                winAmount = 0;
                outcomeSound = 'blackjack_bust'; // Already played, maybe redundant here
            } else if (blackjackDealerBusted) {
                statusMessage = `Dealer Busted! (${blackjackDealerScore}). You win ${formatWin(blackjackBet)}!`;
                winAmount = blackjackBet * REGULAR_WIN_MULTIPLIER; // 1:1 payout
                outcomeSound = 'blackjack_win';
            }
            // Compare scores scenario (neither busted, no Blackjacks)
            else {
                if (blackjackPlayerScore > blackjackDealerScore) {
                    statusMessage = `You win! ${blackjackPlayerScore} vs ${blackjackDealerScore}. Won ${formatWin(blackjackBet)}.`;
                    winAmount = blackjackBet * REGULAR_WIN_MULTIPLIER;
                    outcomeSound = 'blackjack_win';
                } else if (blackjackPlayerScore < blackjackDealerScore) {
                    statusMessage = `Dealer wins! ${blackjackDealerScore} vs ${blackjackPlayerScore}. You lose ${formatWin(blackjackBet)}.`;
                    winAmount = 0;
                    outcomeSound = 'lose';
                } else { // Push
                    statusMessage = `Push! Both have ${blackjackPlayerScore}. Bet ${formatWin(blackjackBet)} returned.`;
                    winAmount = blackjackBet; // Return original bet
                    outcomeSound = 'blackjack_push';
                }
            }

            // Update currency and stats
            const profit = winAmount - blackjackBet;
            currency += winAmount; // Add back winnings (or original bet on push)
            if (profit > 0) {
                totalGain += profit;
                addWinToLeaderboard('Blackjack', profit);
                updateCurrencyDisplay('win');
            } else if (profit < 0) {
                totalLoss += Math.abs(profit); // Or just totalLoss += blackjackBet; if winAmount is 0
                updateCurrencyDisplay(); // No flash on loss (already flashed on deal)
            } else { // Push
                updateCurrencyDisplay(); // No flash on push
            }

            blackjackStatus.textContent = statusMessage;
            playSound(outcomeSound);
            saveGameState(); // Save final game state
        }


        // --- ATM / Loan Logic ---
        function openAtmModal() { playSound('click'); atmModalOverlay.classList.remove('hidden'); atmModal.classList.remove('hidden'); }
        function closeAtmModal() { playSound('click'); atmModalOverlay.classList.add('hidden'); atmModal.classList.add('hidden'); }

        // --- Event Listeners ---

        // Loan/ATM Buttons
        loanButton.addEventListener('click', openAtmModal);
        atmCloseButton.addEventListener('click', closeAtmModal);
        atmModalOverlay.addEventListener('click', closeAtmModal); // Close on overlay click
        atmButtons.forEach(button => {
            button.addEventListener('click', () => {
                const amount = parseInt(button.dataset.amount);
                if (isNaN(amount) || amount <= 0) return;
                startTone(); // Ensure audio context
                playSound('loan');
                currency += amount;
                totalLoanAmount += amount; // Increase loan balance
                updateCurrencyDisplay('win'); // Flash green for getting money
                saveGameState();
                showMessage(`Withdrew ${amount}! Loan balance increased.`, 2000);
                closeAtmModal();
            });
        });
        payLoanButton.addEventListener('click', () => {
            if (currency >= totalLoanAmount && totalLoanAmount > 0) {
                startTone();
                playSound('click'); // Or a specific pay sound
                const paidAmount = totalLoanAmount;
                currency -= totalLoanAmount;
                totalLoanAmount = 0; // Clear loan
                updateCurrencyDisplay('loss'); // Flash red for spending money
                saveGameState();
                showMessage(`Loan of ${paidAmount} paid off!`, 2000);
            } else {
                showMessage(`Not enough funds to pay off loan! Need ${totalLoanAmount}.`, 2000);
            }
        });

        // Tab Switching
        tabSlots.addEventListener('click', () => setActiveTab(tabSlots));
        tabCrash.addEventListener('click', () => setActiveTab(tabCrash));
        tabCoinflip.addEventListener('click', () => setActiveTab(tabCoinflip));
        tabMinefield.addEventListener('click', () => setActiveTab(tabMinefield));
        tabMemory.addEventListener('click', () => setActiveTab(tabMemory));
        tabHorserace.addEventListener('click', () => setActiveTab(tabHorserace));
        tabRoulette.addEventListener('click', () => setActiveTab(tabRoulette));
        tabBlackjack.addEventListener('click', () => setActiveTab(tabBlackjack)); // Listener for Blackjack tab

        // Generic Bet Adjustment Listener Factory
        function addBetAdjustmentListeners(gamePrefix, betInputElement) {
            document.getElementById(`${gamePrefix}-bet-decrease-10`).addEventListener('click', () => adjustBet(betInputElement, 10, 'subtract'));
            document.getElementById(`${gamePrefix}-bet-decrease-1`).addEventListener('click', () => adjustBet(betInputElement, 1, 'subtract'));
            document.getElementById(`${gamePrefix}-bet-increase-1`).addEventListener('click', () => adjustBet(betInputElement, 1, 'add'));
            document.getElementById(`${gamePrefix}-bet-increase-10`).addEventListener('click', () => adjustBet(betInputElement, 10, 'add'));
            document.getElementById(`${gamePrefix}-bet-min`).addEventListener('click', () => adjustBet(betInputElement, 1, 'min'));
            document.getElementById(`${gamePrefix}-bet-half`).addEventListener('click', () => adjustBet(betInputElement, 2, 'divide'));
            document.getElementById(`${gamePrefix}-bet-double`).addEventListener('click', () => adjustBet(betInputElement, 2, 'multiply'));
            document.getElementById(`${gamePrefix}-bet-max`).addEventListener('click', () => adjustBet(betInputElement, currency, 'max'));
            // Update bet on manual input change, clamping to valid range
            betInputElement.addEventListener('change', () => adjustBet(betInputElement, parseInt(betInputElement.value), 'set'));
        }

        // Slot Controls
        spinButton.addEventListener('click', () => { if (isAutoSpinning) stopAutoSpin(); spinReels(); });
        autoSpinToggle.addEventListener('click', toggleAutoSpin);
        addBetAdjustmentListeners('slot', slotBetInput);

        // Crash Controls
        crashBetButton.addEventListener('click', startCrashGame);
        crashCashoutButton.addEventListener('click', attemptCashOut);
        addBetAdjustmentListeners('crash', crashBetInput);
        crashAutoBetToggle.addEventListener('click', toggleCrashAutoBet);
        crashAutoCashoutToggle.addEventListener('click', toggleCrashAutoCashout);
        crashAutoCashoutInput.addEventListener('change', () => {
            // Update target value only if auto-cashout is currently enabled
            if (isAutoCashoutEnabled) {
                const target = parseFloat(crashAutoCashoutInput.value);
                if (!isNaN(target) && target >= 1.01) {
                    autoCashoutTarget = target;
                    crashAutoCashoutInput.value = target.toFixed(2); // Format input
                    showMessage(`Auto-cashout target updated to ${target.toFixed(2)}x`, 1500);
                } else {
                    showMessage("Invalid auto-cashout target. Must be >= 1.01", 2500);
                    // Reset input to previous valid target or placeholder if invalid
                    crashAutoCashoutInput.value = autoCashoutTarget > 0 ? autoCashoutTarget.toFixed(2) : '';
                }
            }
        });


        // Coin Flip Controls
        coinflipButton.addEventListener('click', handleCoinFlip);
        coinflipCashoutButton.addEventListener('click', cashOutCoinFlip);
        addBetAdjustmentListeners('coinflip', coinflipBetInput);
        coinflipChooseBlueBtn.addEventListener('click', () => setCoinFlipChoice('blue'));
        coinflipChooseYellowBtn.addEventListener('click', () => setCoinFlipChoice('yellow'));

        // Minefield Controls
        minefieldStartButton.addEventListener('click', startMinefield);
        minefieldCashoutButton.addEventListener('click', cashOutMinefield);
        addBetAdjustmentListeners('minefield', minefieldBetInput);
        // Tile clicks are handled within createMinefieldGrid

        // Memory Game Controls
        memoryStartButton.addEventListener('click', startMemoryGame);
        addBetAdjustmentListeners('memory', memoryBetInput);
        // Card clicks are handled within createMemoryGrid

        // Horse Race Controls
        horseraceStartButton.addEventListener('click', startHorserace);
        addBetAdjustmentListeners('horserace', horseraceBetInput);
        // Selection clicks are handled within createHorseSelectionUI

        // Roulette Controls
        rouletteSpinButton.addEventListener('click', spinRouletteWheel);
        addBetAdjustmentListeners('roulette', rouletteBetInput);
        // Betting button clicks are handled within createRouletteBettingGrid and adding listeners to outside bets below

        // Blackjack Controls
        blackjackDealButton.addEventListener('click', startBlackjackGame);
        blackjackHitButton.addEventListener('click', blackjackHit);
        blackjackStandButton.addEventListener('click', blackjackStand);
        addBetAdjustmentListeners('blackjack', blackjackBetInput);


        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadGameState(); // Load saved progress first
            setActiveTab(tabSlots); // Default to slots tab

            // Initialize specific game UIs and states
            reelElements.forEach(reelSymbolElement => { // Set initial reel state
                reelSymbolElement.innerHTML = `<div style="height: 100px; line-height: 100px;">❓</div>`;
            });
            resetCrashVisuals(); // Set initial crash graph state
            displayPayoutLegend(); // Populate slot payouts
            updateCrashAutoCashoutToggleVisuals(); // Set initial state of crash auto-cashout controls
            createMinefieldGrid(); // Build the minefield grid structure
            resetMinefield(); // Set initial minefield state
            resetCoinFlip(); // Set initial coinflip state
            createMemoryGrid(); // Build the memory grid structure
            resetMemoryGame(); // Set initial memory game state
            createHorseSelectionUI(); // Create horse selection buttons
            // Horses elements are created when tab becomes active via setActiveTab
            resetHorserace(); // Set initial horse race state

            // Roulette Initialization
            initializeRouletteColors(); // Define number colors
            // Roulette grid is created when tab becomes active
            resetRoulette(); // Set initial roulette state
            // Add listeners for outside bet buttons (since they exist in HTML)
            rouletteOutsideBetsContainer.querySelectorAll('.roulette-bet-btn').forEach(button => {
                button.addEventListener('click', () => selectRouletteBet(button.dataset.betType, null, button));
            });

            // Blackjack Initialization
            resetBlackjack(); // Set initial Blackjack state

            // Trigger entrance animations for cards
            const cards = document.querySelectorAll('.grid-col-1 > div, .grid-col-2 > div, .grid-col-about');
            cards.forEach((card, index) => {
                card.classList.add('animate-card-enter');
                card.style.animationDelay = `${index * 0.05}s`; // Stagger animation
            });

            // Initialize Tone.js on first user interaction anywhere on the body
            document.body.addEventListener('click', startTone, { once: true });

            // Ensure initial state for crash input is correct after loading potentially saved state
            updateCrashAutoCashoutToggleVisuals();
        });
    </script>
</body>
</html>